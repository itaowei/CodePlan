<html><body><pre><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Support\LamdaPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\AsyncSubscriber.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\IllegalStateException.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\api\Reactive.Streams\IPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\AtomicCounter.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\AtomicReference.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\AtomicBoolean.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\Option.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\ISubscriberWhiteboxVerificationRules.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\AsyncIterablePublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\Properties\AssemblyInfo.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\AtomicCounterLong.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\IPublisherVerificationRules .cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\WithHelperPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\IllegalStateException.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Properties\AssemblyInfo.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Properties\AssemblyInfo.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\api\Reactive.Streams\ISubscriber.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Support\LamdaSubscriber.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\HelperPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\TestException.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\SharedAssemblyInfo.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\SubscriberBufferOverflowException.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\api\Reactive.Streams\IProcessor.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\api\Reactive.Streams\ISubscription.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\IdentityProcessorVerificationDelegationTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Support\LamdaSubscription.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Support\SyncTriggeredDemandSubscriber.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\InfiniteHelperPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\Properties\AssemblyInfo.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\Support\ISubscriberBlackboxVerificationRules.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\SyncSubscriber.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\AtomicBoolean.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\InfiniteIncrementNumberPublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast\NumberIterablePublisher.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>src\tck\Reactive.Streams.TCK\SubscriberWhiteboxVerification.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index b6ad3c5..5766502 100644<br><span style="color:blue;">@@ -37,7 +37,6 @@ protected SubscriberWhiteboxVerification(TestEnvironment environment)</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:orangered;">-        </span><br>         public void SetUp() => _environment.ClearAsyncErrors();<br> <br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 5766502..b6ad3c5 100644<br><span style="color:blue;">@@ -37,6 +37,7 @@ protected SubscriberWhiteboxVerification(TestEnvironment environment)</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:green;">+        </span><br>         public void SetUp() => _environment.ClearAsyncErrors();<br> <br> <br><hr><h1>src\tck\Reactive.Streams.TCK\SubscriberBlackboxVerification.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 5ea008f..baa20c0 100644<br><span style="color:blue;">@@ -50,7 +50,6 @@ public virtual void TriggerRequest(ISubscriber<T> subscriber)</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:orangered;">-        </span><br>         public void Setup() => Environment.ClearAsyncErrors();<br> <br>         ////////////////////// SPEC RULE VERIFICATION ///////////////////////////////<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index baa20c0..5ea008f 100644<br><span style="color:blue;">@@ -50,6 +50,7 @@ public virtual void TriggerRequest(ISubscriber<T> subscriber)</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:green;">+        </span><br>         public void Setup() => Environment.ClearAsyncErrors();<br> <br>         ////////////////////// SPEC RULE VERIFICATION ///////////////////////////////<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\AsyncSubscriberTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 06fff0f..2c2c9e6 100644<br><span style="color:blue;">@@ -10,10 +10,9 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class AsyncSubscriberTest : SubscriberBlackboxVerification<int?><br>     {<br><span style="color:orangered;">-        public AsyncSubscriberTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public AsyncSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 2c2c9e6..06fff0f 100644<br><span style="color:blue;">@@ -10,9 +10,10 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:green;">+    </span><br>     public class AsyncSubscriberTest : SubscriberBlackboxVerification<int?><br>     {<br><span style="color:orangered;">-        public AsyncSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+        public AsyncSubscriberTest() : base(new TestEnvironment())</span><br>         {<br>         }<br> <br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\IterablePublisherTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 101f550..e60f412 100644<br><span style="color:blue;">@@ -10,10 +10,9 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class IterablePublisherTest : PublisherVerification<int?><br>     {<br><span style="color:orangered;">-        public IterablePublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public IterablePublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 101f550..d50a191 100644<br><span style="color:blue;">@@ -9,11 +9,13 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class IterablePublisherTest : PublisherVerification<int?><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public IterablePublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public IterablePublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -43,5 +45,7 @@ private sealed class FailedEnumerable : IEnumerable<int?></span><br>         }<br> <br>         public override long MaxElementsFromPublisher { get; } = int.MaxValue;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index e60f412..d50a191 100644<br><span style="color:blue;">@@ -9,8 +9,11 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class IterablePublisherTest : PublisherVerification<int?><br><span style="color:green;">+</span><br>     {<br>         public IterablePublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -42,5 +45,7 @@ private sealed class FailedEnumerable : IEnumerable<int?></span><br>         }<br> <br>         public override long MaxElementsFromPublisher { get; } = int.MaxValue;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\UnboundedIntegerIncrementPublisherTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 7836cc8..e7a1506 100644<br><span style="color:blue;">@@ -10,10 +10,9 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class UnboundedIntegerIncrementPublisherTest : PublisherVerification<int?><br>     {<br><span style="color:orangered;">-        public UnboundedIntegerIncrementPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public UnboundedIntegerIncrementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 7836cc8..42c5483 100644<br><span style="color:blue;">@@ -9,11 +9,13 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class UnboundedIntegerIncrementPublisherTest : PublisherVerification<int?><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public UnboundedIntegerIncrementPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public UnboundedIntegerIncrementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -40,5 +42,7 @@ private sealed class FailedEnumerable : IEnumerable<int?></span><br>         }<br> <br>         public override long MaxElementsFromPublisher => PublisherUnableToSignalOnComplete;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index e7a1506..42c5483 100644<br><span style="color:blue;">@@ -9,8 +9,11 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class UnboundedIntegerIncrementPublisherTest : PublisherVerification<int?><br><span style="color:green;">+</span><br>     {<br>         public UnboundedIntegerIncrementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -39,5 +42,7 @@ private sealed class FailedEnumerable : IEnumerable<int?></span><br>         }<br> <br>         public override long MaxElementsFromPublisher => PublisherUnableToSignalOnComplete;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\EmptyLazyPublisherTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index dc63ad1..68b7f92 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System.Linq;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -8,10 +8,9 @@</span><br> <br> namespace Reactive.Streams.TCK.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class EmptyLazyPublisherTest : PublisherVerification<int><br>     {<br><span style="color:orangered;">-        public EmptyLazyPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public EmptyLazyPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>             <br>         }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index dc63ad1..30e6b5c 100644<br><span style="color:blue;">@@ -7,11 +7,13 @@</span><br> using Reactive.Streams.Example.Unicast;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class EmptyLazyPublisherTest : PublisherVerification<int><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public EmptyLazyPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public EmptyLazyPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>             <br>         }<br><span style="color:blue;">@@ -22,5 +24,7 @@ public override IPublisher<int> CreatePublisher(long elements)</span><br>         public override IPublisher<int> CreateFailedPublisher() => null;<br> <br>         public override long MaxElementsFromPublisher { get; } = 0;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 68b7f92..30e6b5c 100644<br><span style="color:blue;">@@ -1,14 +1,17 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System.Linq;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.Example.Unicast;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class EmptyLazyPublisherTest : PublisherVerification<int><br><span style="color:green;">+</span><br>     {<br>         public EmptyLazyPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -21,5 +24,7 @@ public override IPublisher<int> CreatePublisher(long elements)</span><br>         public override IPublisher<int> CreateFailedPublisher() => null;<br> <br>         public override long MaxElementsFromPublisher { get; } = 0;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\Support\TCKVerificationSupport.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index f612d7d..28986e0 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index f612d7d..318c195 100644<br><span style="color:blue;">@@ -135,7 +135,7 @@ private bool FindDeepErrorMessage(Exception exception, string messagePart, int d</span><br>         {<br>             if (exception is NullReferenceException)<br>             {<br><span style="color:orangered;">-                TckAssert.Fail($"{nameof(NullReferenceException)} was thrown, definitely not a helpful error!",</span><br><span style="color:green;">+                TckTckTckTckTckTckTckAssert.Fail($"{nameof(NullReferenceException)} was thrown, definitely not a helpful error!",</span><br>                     exception);<br>             }<br>             if (exception == null || depth == 0)<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 28986e0..318c195 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -135,7 +135,7 @@ private bool FindDeepErrorMessage(Exception exception, string messagePart, int d</span><br>         {<br>             if (exception is NullReferenceException)<br>             {<br><span style="color:orangered;">-                TckAssert.Fail($"{nameof(NullReferenceException)} was thrown, definitely not a helpful error!",</span><br><span style="color:green;">+                TckTckTckTckTckTckTckAssert.Fail($"{nameof(NullReferenceException)} was thrown, definitely not a helpful error!",</span><br>                     exception);<br>             }<br>             if (exception == null || depth == 0)<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\SyncTriggeredDemandSubscriberTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index fe39da7..0e7dd7c 100644<br><span style="color:blue;">@@ -7,10 +7,9 @@</span><br> <br> namespace Reactive.Streams.TCK.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class SyncTriggeredDemandSubscriberTest : SubscriberBlackboxVerification<int?><br>     {<br><span style="color:orangered;">-        public SyncTriggeredDemandSubscriberTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SyncTriggeredDemandSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index fe39da7..424d5ea 100644<br><span style="color:blue;">@@ -6,17 +6,19 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SyncTriggeredDemandSubscriberTest : SubscriberBlackboxVerification<int?><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public SyncTriggeredDemandSubscriberTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SyncTriggeredDemandSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br>         public override void TriggerRequest(ISubscriber<int?> subscriber)<br>             => ((SyncTriggeredDemandSubscriber<int?>) subscriber).TriggerDemand(1);<br><span style="color:orangered;">-        </span><br><span style="color:green;">+</span><br> <br>         public override ISubscriber<int?> CreateSubscriber() => new Subscriber();<br> <br><span style="color:blue;">@@ -36,5 +38,7 @@ public override void OnComplete()</span><br>         }<br> <br>         public override int? CreateElement(int element) => element;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 0e7dd7c..424d5ea 100644<br><span style="color:blue;">@@ -6,8 +6,11 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class SyncTriggeredDemandSubscriberTest : SubscriberBlackboxVerification<int?><br><span style="color:green;">+</span><br>     {<br>         public SyncTriggeredDemandSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -15,7 +18,7 @@ public SyncTriggeredDemandSubscriberTest(ITestOutputHelper output) : base(new Te</span><br> <br>         public override void TriggerRequest(ISubscriber<int?> subscriber)<br>             => ((SyncTriggeredDemandSubscriber<int?>) subscriber).TriggerDemand(1);<br><span style="color:orangered;">-        </span><br><span style="color:green;">+</span><br> <br>         public override ISubscriber<int?> CreateSubscriber() => new Subscriber();<br> <br><span style="color:blue;">@@ -35,5 +38,7 @@ public override void OnComplete()</span><br>         }<br> <br>         public override int? CreateElement(int element) => element;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\SingleElementPublisherTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index c22e7f5..0862005 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System.Linq;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -8,10 +8,9 @@</span><br> <br> namespace Reactive.Streams.TCK.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class SingleElementPublisherTest : PublisherVerification<int><br>     {<br><span style="color:orangered;">-        public SingleElementPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SingleElementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>             <br>         }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index c22e7f5..65c471d 100644<br><span style="color:blue;">@@ -7,11 +7,13 @@</span><br> using Reactive.Streams.Example.Unicast;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SingleElementPublisherTest : PublisherVerification<int><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public SingleElementPublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SingleElementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>             <br>         }<br><span style="color:blue;">@@ -22,5 +24,7 @@ public override IPublisher<int> CreatePublisher(long elements)</span><br>         public override IPublisher<int> CreateFailedPublisher() => null;<br> <br>         public override long MaxElementsFromPublisher { get; } = 1;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 0862005..65c471d 100644<br><span style="color:blue;">@@ -1,14 +1,17 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System.Linq;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.Example.Unicast;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class SingleElementPublisherTest : PublisherVerification<int><br><span style="color:green;">+</span><br>     {<br>         public SingleElementPublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -21,5 +24,7 @@ public override IPublisher<int> CreatePublisher(long elements)</span><br>         public override IPublisher<int> CreateFailedPublisher() => null;<br> <br>         public override long MaxElementsFromPublisher { get; } = 1;<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\SyncTriggeredDemandSubscriberWhiteboxTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 89e6634..9b00c1c 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -8,10 +8,9 @@</span><br> <br> namespace Reactive.Streams.TCK.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class SyncTriggeredDemandSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br>     {<br><span style="color:orangered;">-        public SyncTriggeredDemandSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SyncTriggeredDemandSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 89e6634..0c6a312 100644<br><span style="color:blue;">@@ -7,11 +7,13 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SyncTriggeredDemandSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public SyncTriggeredDemandSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SyncTriggeredDemandSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -69,5 +71,7 @@ public override void OnComplete()</span><br> <br>             protected override long Foreach(int? element) => 1;<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 9b00c1c..0c6a312 100644<br><span style="color:blue;">@@ -1,14 +1,17 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class SyncTriggeredDemandSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br><span style="color:green;">+</span><br>     {<br>         public SyncTriggeredDemandSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -68,5 +71,7 @@ public override void OnComplete()</span><br> <br>             protected override long Foreach(int? element) => 1;<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK\IdentityProcessorVerification.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 7e41029..81df489 100644<br><span style="color:blue;">@@ -152,7 +152,7 @@ public override ISubscriber<T> CreateSubscriber(WhiteboxSubscriberProbe<T> probe</span><br>         /// <summary><br>         /// Describes the tested implementation in terms of how many subscribers they can support.<br>         /// Some tests require the <see cref="IPublisher{T}"/> under test to support multiple Subscribers,<br><span style="color:orangered;">-        /// yet the spec does not require all publishers to be able to do so, thus â€“ if an implementation</span><br><span style="color:green;">+        /// yet the spec does not require all publishers to be able to do so, thus – if an implementation</span><br>         /// supports only a limited number of subscribers (e.g. only 1 subscriber, also known as "no fanout")<br>         /// you MUST return that number from this method by overriding it.<br>         /// </summary><br><span style="color:blue;">@@ -160,7 +160,6 @@ public override ISubscriber<T> CreateSubscriber(WhiteboxSubscriberProbe<T> probe</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:orangered;">-        </span><br>         public void SetUp()<br>         {<br>             _publisherVerification.SetUp();<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 81df489..7e41029 100644<br><span style="color:blue;">@@ -152,7 +152,7 @@ public override ISubscriber<T> CreateSubscriber(WhiteboxSubscriberProbe<T> probe</span><br>         /// <summary><br>         /// Describes the tested implementation in terms of how many subscribers they can support.<br>         /// Some tests require the <see cref="IPublisher{T}"/> under test to support multiple Subscribers,<br><span style="color:orangered;">-        /// yet the spec does not require all publishers to be able to do so, thus – if an implementation</span><br><span style="color:green;">+        /// yet the spec does not require all publishers to be able to do so, thus â€“ if an implementation</span><br>         /// supports only a limited number of subscribers (e.g. only 1 subscriber, also known as "no fanout")<br>         /// you MUST return that number from this method by overriding it.<br>         /// </summary><br><span style="color:blue;">@@ -160,6 +160,7 @@ public override ISubscriber<T> CreateSubscriber(WhiteboxSubscriberProbe<T> probe</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:green;">+        </span><br>         public void SetUp()<br>         {<br>             _publisherVerification.SetUp();<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\SyncSubscriberWhiteboxTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index a24ac7c..23df0ba 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -8,10 +8,9 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class ValueTypeSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int><br>     {<br><span style="color:orangered;">-        public ValueTypeSyncSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public ValueTypeSyncSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -71,10 +70,9 @@ public override void OnComplete()</span><br>         }<br>     }<br> <br><span style="color:orangered;">-    </span><br>     public class NullableSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br>     {<br><span style="color:orangered;">-        public NullableSyncSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public NullableSyncSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index a24ac7c..8bcac01 100644<br><span style="color:blue;">@@ -7,11 +7,13 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class ValueTypeSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public ValueTypeSyncSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public ValueTypeSyncSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -69,9 +71,10 @@ public override void OnComplete()</span><br>                 _probe.RegisterOnComplete();<br>             }<br>         }<br><span style="color:green;">+</span><br>     }<br> <br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class NullableSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br>     {<br>         public NullableSyncSubscriberWhiteboxTest() : base(new TestEnvironment())<br><span style="color:blue;">@@ -133,4 +136,5 @@ public override void OnComplete()</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 23df0ba..8bcac01 100644<br><span style="color:blue;">@@ -1,14 +1,17 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class ValueTypeSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int><br><span style="color:green;">+</span><br>     {<br>         public ValueTypeSyncSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:blue;">@@ -68,11 +71,13 @@ public override void OnComplete()</span><br>                 _probe.RegisterOnComplete();<br>             }<br>         }<br><span style="color:green;">+</span><br>     }<br> <br><span style="color:green;">+</span><br>     public class NullableSyncSubscriberWhiteboxTest : SubscriberWhiteboxVerification<int?><br>     {<br><span style="color:orangered;">-        public NullableSyncSubscriberWhiteboxTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+        public NullableSyncSubscriberWhiteboxTest() : base(new TestEnvironment())</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -131,4 +136,5 @@ public override void OnComplete()</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\examples\Reactive.Streams.Example.Unicast.Tests\SyncSubscriberTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 7465dbc..087bdfe 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -8,28 +8,36 @@</span><br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br> {<br><span style="color:orangered;">-    </span><br>     public class SyncSubscriberTest : SubscriberBlackboxVerification<int?><br>     {<br><span style="color:orangered;">-        public SyncSubscriberTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public SyncSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br><span style="color:green;">+            _output = output;</span><br>         }<br> <br>         public override int? CreateElement(int element) => element;<br> <br><span style="color:orangered;">-        public override ISubscriber<int?> CreateSubscriber() => new Subscriber();</span><br><span style="color:green;">+        public override ISubscriber<int?> CreateSubscriber() => new Subscriber(_output);</span><br> <br>         private sealed class Subscriber : SyncSubscriber<int?><br>         {<br><span style="color:green;">+            private readonly ITestOutputHelper _output;</span><br>             private long _acc;<br> <br><span style="color:green;">+            public Subscriber(ITestOutputHelper output)</span><br><span style="color:green;">+            {</span><br><span style="color:green;">+                _output = output;</span><br><span style="color:green;">+            }</span><br><span style="color:green;">+</span><br>             protected override bool WhenNext(int? element)<br>             {<br>                 _acc += element.Value;<br>                 return true;<br>             }<br> <br><span style="color:orangered;">-            public override void OnComplete() => Console.WriteLine("Accumulated: " + _acc);</span><br><span style="color:green;">+            public override void OnComplete() => _output?.WriteLine("Accumulated: " + _acc);</span><br>         }<br>     }<br> }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 7465dbc..c81e4c3 100644<br><span style="color:blue;">@@ -7,11 +7,13 @@</span><br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SyncSubscriberTest : SubscriberBlackboxVerification<int?><br><span style="color:green;">+</span><br>     {<br><span style="color:orangered;">-        public SyncSubscriberTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public SyncSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -20,8 +22,10 @@ public SyncSubscriberTest() : base(new TestEnvironment())</span><br>         public override ISubscriber<int?> CreateSubscriber() => new Subscriber();<br> <br>         private sealed class Subscriber : SyncSubscriber<int?><br><span style="color:green;">+</span><br>         {<br>             private long _acc;<br><span style="color:green;">+            private readonly ITestOutputHelper _output;</span><br> <br>             protected override bool WhenNext(int? element)<br>             {<br><span style="color:blue;">@@ -29,7 +33,10 @@ protected override bool WhenNext(int? element)</span><br>                 return true;<br>             }<br> <br><span style="color:orangered;">-            public override void OnComplete() => Console.WriteLine("Accumulated: " + _acc);</span><br><span style="color:green;">+            public override void OnComplete() => _output.WriteLine("Accumulated: " + _acc);</span><br><span style="color:green;">+</span><br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 087bdfe..c81e4c3 100644<br><span style="color:blue;">@@ -1,35 +1,31 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK;<br> <br> namespace Reactive.Streams.Example.Unicast.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:green;">+</span><br>     public class SyncSubscriberTest : SubscriberBlackboxVerification<int?><br><span style="color:orangered;">-    {</span><br><span style="color:orangered;">-        private readonly ITestOutputHelper _output;</span><br> <br><span style="color:green;">+    {</span><br>         public SyncSubscriberTest(ITestOutputHelper output) : base(new TestEnvironment(output))<br>         {<br><span style="color:orangered;">-            _output = output;</span><br>         }<br> <br>         public override int? CreateElement(int element) => element;<br> <br><span style="color:orangered;">-        public override ISubscriber<int?> CreateSubscriber() => new Subscriber(_output);</span><br><span style="color:green;">+        public override ISubscriber<int?> CreateSubscriber() => new Subscriber();</span><br> <br>         private sealed class Subscriber : SyncSubscriber<int?><br><span style="color:green;">+</span><br>         {<br><span style="color:orangered;">-            private readonly ITestOutputHelper _output;</span><br>             private long _acc;<br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            public Subscriber(ITestOutputHelper output)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                _output = output;</span><br><span style="color:orangered;">-            }</span><br><span style="color:green;">+            private readonly ITestOutputHelper _output;</span><br> <br>             protected override bool WhenNext(int? element)<br>             {<br><span style="color:blue;">@@ -37,7 +33,10 @@ protected override bool WhenNext(int? element)</span><br>                 return true;<br>             }<br> <br><span style="color:orangered;">-            public override void OnComplete() => _output?.WriteLine("Accumulated: " + _acc);</span><br><span style="color:green;">+            public override void OnComplete() => _output.WriteLine("Accumulated: " + _acc);</span><br><span style="color:green;">+</span><br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK\PublisherVerification.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 6506830..5015758 100644<br><span style="color:blue;">@@ -4,12 +4,11 @@</span><br> using System;<br> using System.Collections.Generic;<br> using System.Threading;<br><span style="color:green;">+using FluentAssertions;</span><br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Support;<br> <br><span style="color:orangered;">-//using Reactive.Streams.TCK.Support;</span><br><span style="color:orangered;">-</span><br> namespace Reactive.Streams.TCK<br> {<br>     public abstract class PublisherVerification<T> : IPublisherVerificationRules<br><span style="color:blue;">@@ -118,7 +117,6 @@ public static long EnvironmentPublisherReferenceGcTimeoutMilliseconds()</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:orangered;">-        </span><br>         public void SetUp() => _environment.ClearAsyncErrors();<br> <br>         ////////////////////// TEST SETUP VERIFICATION //////////////////////////////<br><span style="color:blue;">@@ -674,7 +672,6 @@ public void Optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequen</span><br>                 // NOTE: can't check completion, the Publisher may not be able to signal it<br>                 //       a similar test *with* completion checking is implemented<br> <br><span style="color:orangered;">-</span><br>                 received1.Should().BeEquivalentTo(received2,<br>                     "Expected elements to be signaled in the same sequence to 1st and 2nd subscribers");<br>                 received2.Should().BeEquivalentTo(received3,<br><span style="color:blue;">@@ -1161,10 +1158,12 @@ public void OptionalActivePublisherTest(long elements, bool completionSignalRequ</span><br>             {<br>                 NotVerified(skipMessage + "Reason for skipping was: " + ex.Message);<br>             }<br><span style="color:green;">+            /*</span><br>             catch (Exception)<br>             {<br>                 NotVerified(skipMessage);<br>             }<br><span style="color:green;">+            */</span><br>         }<br> <br>         public const string SkippingNoErrorPublisherAvailable =<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 6506830..c343eec 100644<br><span style="color:blue;">@@ -7,18 +7,19 @@</span><br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Support;<br><span style="color:green;">+using FluentAssertions;</span><br> <br> //using Reactive.Streams.TCK.Support;<br> <br> namespace Reactive.Streams.TCK<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    public abstract class PublisherVerification<T> : IPublisherVerificationRules</span><br><span style="color:green;">+    public abstract class PublisherVerification <T> : IPublisherVerificationRules</span><br>     {<br>         private const string PublisherReferenceGcTimeoutMillisecondsEnvironment = "PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS";<br>         private const long DefaultPublisherReferenceGcTimeoutMilliseconds = 300;<br><span style="color:orangered;">-</span><br><span style="color:orangered;">-</span><br>         private readonly TestEnvironment _environment;<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br> <br>         /// <summary><br>         /// The amount of time after which a cancelled Subscriber reference should be dropped.<br><span style="color:blue;">@@ -118,7 +119,7 @@ public static long EnvironmentPublisherReferenceGcTimeoutMilliseconds()</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:orangered;">-        </span><br><span style="color:green;">+</span><br>         public void SetUp() => _environment.ClearAsyncErrors();<br> <br>         ////////////////////// TEST SETUP VERIFICATION //////////////////////////////<br><span style="color:blue;">@@ -597,6 +598,7 @@ public void Optional_spec111_maySupportMultiSubscribe()</span><br>             });<br> <br>         // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#1.11<br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne()<br>             => OptionalActivePublisherTest(5, true, publisher =><br><span style="color:blue;">@@ -1216,4 +1218,5 @@ public void StochasticTest(int n, Action<int> body)</span><br>         /// </summary><br>         public long PublisherUnableToSignalOnComplete { get; } = long.MaxValue;<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 5015758..c343eec 100644<br><span style="color:blue;">@@ -4,20 +4,22 @@</span><br> using System;<br> using System.Collections.Generic;<br> using System.Threading;<br><span style="color:orangered;">-using FluentAssertions;</span><br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Support;<br><span style="color:green;">+using FluentAssertions;</span><br><span style="color:green;">+</span><br><span style="color:green;">+//using Reactive.Streams.TCK.Support;</span><br> <br> namespace Reactive.Streams.TCK<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    public abstract class PublisherVerification<T> : IPublisherVerificationRules</span><br><span style="color:green;">+    public abstract class PublisherVerification <T> : IPublisherVerificationRules</span><br>     {<br>         private const string PublisherReferenceGcTimeoutMillisecondsEnvironment = "PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS";<br>         private const long DefaultPublisherReferenceGcTimeoutMilliseconds = 300;<br><span style="color:orangered;">-</span><br><span style="color:orangered;">-</span><br>         private readonly TestEnvironment _environment;<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br> <br>         /// <summary><br>         /// The amount of time after which a cancelled Subscriber reference should be dropped.<br><span style="color:blue;">@@ -117,6 +119,7 @@ public static long EnvironmentPublisherReferenceGcTimeoutMilliseconds()</span><br> <br>         ////////////////////// TEST ENV CLEANUP /////////////////////////////////////<br> <br><span style="color:green;">+</span><br>         public void SetUp() => _environment.ClearAsyncErrors();<br> <br>         ////////////////////// TEST SETUP VERIFICATION //////////////////////////////<br><span style="color:blue;">@@ -595,6 +598,7 @@ public void Optional_spec111_maySupportMultiSubscribe()</span><br>             });<br> <br>         // Verifies rule: https://github.com/reactive-streams/reactive-streams-jvm#1.11<br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne()<br>             => OptionalActivePublisherTest(5, true, publisher =><br><span style="color:blue;">@@ -672,6 +676,7 @@ public void Optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequen</span><br>                 // NOTE: can't check completion, the Publisher may not be able to signal it<br>                 //       a similar test *with* completion checking is implemented<br> <br><span style="color:green;">+</span><br>                 received1.Should().BeEquivalentTo(received2,<br>                     "Expected elements to be signaled in the same sequence to 1st and 2nd subscribers");<br>                 received2.Should().BeEquivalentTo(received3,<br><span style="color:blue;">@@ -1158,12 +1163,10 @@ public void OptionalActivePublisherTest(long elements, bool completionSignalRequ</span><br>             {<br>                 NotVerified(skipMessage + "Reason for skipping was: " + ex.Message);<br>             }<br><span style="color:orangered;">-            /*</span><br>             catch (Exception)<br>             {<br>                 NotVerified(skipMessage);<br>             }<br><span style="color:orangered;">-            */</span><br>         }<br> <br>         public const string SkippingNoErrorPublisherAvailable =<br><span style="color:blue;">@@ -1215,4 +1218,5 @@ public void StochasticTest(int n, Action<int> body)</span><br>         /// </summary><br>         public long PublisherUnableToSignalOnComplete { get; } = long.MaxValue;<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\SubscriberWhiteboxVerificationTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 20860ff..8615fe7 100644<br><span style="color:blue;">@@ -14,9 +14,15 @@ namespace Reactive.Streams.TCK.Tests</span><br>     /// Validates that the TCK's <see cref="SubscriberWhiteboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:orangered;">-    </span><br>     public class SubscriberWhiteboxVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public SubscriberWhiteboxVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Required_spec201_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>         {<br><span style="color:blue;">@@ -258,15 +264,11 @@ public void Required_spec308_requestMustRegisterGivenNumberElementsToBeProduced_</span><br>         /// This verification can be used in the "simples case, subscriber which does basically nothing case" validation.<br>         /// </summary><br>         private SubscriberWhiteboxVerification<int?> SimpleSubscriberVerification()<br><span style="color:orangered;">-            => new SimpleWhiteboxVerification(new TestEnvironment());</span><br><span style="color:green;">+            => new SimpleWhiteboxVerification(new TestEnvironment(_output));</span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class SimpleWhiteboxVerification : SubscriberWhiteboxVerification<int?><br>         {<br><span style="color:orangered;">-            /// <summary></span><br><span style="color:orangered;">-            /// We need this constructor for NUnit even if the fixture is ignored </span><br><span style="color:orangered;">-            /// </summary></span><br><span style="color:orangered;">-            public SimpleWhiteboxVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public SimpleWhiteboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -292,17 +294,13 @@ public SimpleWhiteboxVerification(TestEnvironment environment) : base(environmen</span><br>         /// </summary><br>         private SubscriberWhiteboxVerification<int?> CustomSubscriberVerification(<br>             Func<WhiteboxSubscriberProbe<int?>, ISubscriber<int?>> newSubscriber)<br><span style="color:orangered;">-            => new CustomWhiteboxVerification(new TestEnvironment(), newSubscriber);</span><br><span style="color:green;">+            => new CustomWhiteboxVerification(new TestEnvironment(_output), newSubscriber);</span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class CustomWhiteboxVerification : SubscriberWhiteboxVerification<int?><br>         {<br>             private readonly Func<WhiteboxSubscriberProbe<int?>, ISubscriber<int?>> _newSubscriber;<br> <br><span style="color:orangered;">-            /// <summary></span><br><span style="color:orangered;">-            /// We need this constructor for NUnit even if the fixture is ignored </span><br><span style="color:orangered;">-            /// </summary></span><br><span style="color:orangered;">-            public CustomWhiteboxVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public CustomWhiteboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 20860ff..59e5440 100644<br><span style="color:blue;">@@ -9,14 +9,22 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     /// <summary><br>     /// Validates that the TCK's <see cref="SubscriberWhiteboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SubscriberWhiteboxVerificationTest : TCKVerificationSupport<br><span style="color:green;">+</span><br>     {<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public SubscriberWhiteboxVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br>         [SkippableFact]<br>         public void Required_spec201_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>         {<br><span style="color:blue;">@@ -257,11 +265,12 @@ public void Required_spec308_requestMustRegisterGivenNumberElementsToBeProduced_</span><br>         /// <br>         /// This verification can be used in the "simples case, subscriber which does basically nothing case" validation.<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberWhiteboxVerification<int?> SimpleSubscriberVerification()<br><span style="color:orangered;">-            => new SimpleWhiteboxVerification(new TestEnvironment());</span><br><span style="color:green;">+            => new SimpleWhiteboxVerification(new TestEnvironment(_output));</span><br><span style="color:green;">+</span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class SimpleWhiteboxVerification : SubscriberWhiteboxVerification<int?></span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br><span style="color:orangered;">-        private sealed class SimpleWhiteboxVerification : SubscriberWhiteboxVerification<int?></span><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br><span style="color:blue;">@@ -285,14 +294,16 @@ public SimpleWhiteboxVerification(TestEnvironment environment) : base(environmen</span><br>                     onError: probe.RegisterOnError,<br>                     onComplete: probe.RegisterOnComplete);<br>             }<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br>         /// Verification using a Subscriber that can be fine tuned by the TCK implementer<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberWhiteboxVerification<int?> CustomSubscriberVerification(<br>             Func<WhiteboxSubscriberProbe<int?>, ISubscriber<int?>> newSubscriber)<br><span style="color:orangered;">-            => new CustomWhiteboxVerification(new TestEnvironment(), newSubscriber);</span><br><span style="color:green;">+            => new CustomWhiteboxVerification(new TestEnvironment(_output), newSubscriber);</span><br> <br>         [TestFixture(Ignore = "Helper verification for single test")]<br>         private sealed class CustomWhiteboxVerification : SubscriberWhiteboxVerification<int?><br><span style="color:blue;">@@ -382,5 +393,7 @@ private class SimpleSubscriberWithProbe : ISubscriber<int?></span><br>             [MethodImpl(MethodImplOptions.NoInlining)]<br>             public void OnError(Exception cause) => _onError(cause);<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 8615fe7..59e5440 100644<br><span style="color:blue;">@@ -9,12 +9,15 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     /// <summary><br>     /// Validates that the TCK's <see cref="SubscriberWhiteboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:green;">+</span><br>     public class SubscriberWhiteboxVerificationTest : TCKVerificationSupport<br><span style="color:green;">+</span><br>     {<br>         private readonly ITestOutputHelper _output;<br> <br><span style="color:blue;">@@ -22,7 +25,6 @@ public SubscriberWhiteboxVerificationTest(ITestOutputHelper output)</span><br>         {<br>             _output = output;<br>         }<br><span style="color:orangered;">-</span><br>         [SkippableFact]<br>         public void Required_spec201_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>         {<br><span style="color:blue;">@@ -263,12 +265,17 @@ public void Required_spec308_requestMustRegisterGivenNumberElementsToBeProduced_</span><br>         /// <br>         /// This verification can be used in the "simples case, subscriber which does basically nothing case" validation.<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberWhiteboxVerification<int?> SimpleSubscriberVerification()<br>             => new SimpleWhiteboxVerification(new TestEnvironment(_output));<br> <br><span style="color:orangered;">-        private sealed class SimpleWhiteboxVerification : SubscriberWhiteboxVerification<int?></span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class SimpleWhiteboxVerification : SubscriberWhiteboxVerification<int?></span><br><span style="color:green;">+</span><br>         {<br><span style="color:orangered;">-            public SimpleWhiteboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            /// <summary></span><br><span style="color:green;">+            /// We need this constructor for NUnit even if the fixture is ignored </span><br><span style="color:green;">+            /// </summary></span><br><span style="color:green;">+            public SimpleWhiteboxVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -287,20 +294,26 @@ public SimpleWhiteboxVerification(TestEnvironment environment) : base(environmen</span><br>                     onError: probe.RegisterOnError,<br>                     onComplete: probe.RegisterOnComplete);<br>             }<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br>         /// Verification using a Subscriber that can be fine tuned by the TCK implementer<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberWhiteboxVerification<int?> CustomSubscriberVerification(<br>             Func<WhiteboxSubscriberProbe<int?>, ISubscriber<int?>> newSubscriber)<br>             => new CustomWhiteboxVerification(new TestEnvironment(_output), newSubscriber);<br> <br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class CustomWhiteboxVerification : SubscriberWhiteboxVerification<int?><br>         {<br>             private readonly Func<WhiteboxSubscriberProbe<int?>, ISubscriber<int?>> _newSubscriber;<br> <br><span style="color:orangered;">-            public CustomWhiteboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            /// <summary></span><br><span style="color:green;">+            /// We need this constructor for NUnit even if the fixture is ignored </span><br><span style="color:green;">+            /// </summary></span><br><span style="color:green;">+            public CustomWhiteboxVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -380,5 +393,7 @@ private class SimpleSubscriberWithProbe : ISubscriber<int?></span><br>             [MethodImpl(MethodImplOptions.NoInlining)]<br>             public void OnError(Exception cause) => _onError(cause);<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\IdentityProcessorVerificationTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 37d1ac7..d53b911 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -15,23 +15,29 @@ public class IdentityProcessorVerificationTest : TCKVerificationSupport</span><br>         private static readonly long DefaultNoSignalsTimeoutMilliseconds =<br>             TestEnvironment.EnvironmentDefaultNoSignalsTimeoutMilliseconds();<br> <br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public IdentityProcessorVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError_shouldBeIgnored()<br>         {<br>             RequireTestSkip(() =><br>             {<br><span style="color:orangered;">-                new Spec104IgnoreVerification(NewTestEnvironment())</span><br><span style="color:green;">+                new Spec104IgnoreVerification(NewTestEnvironment(_output))</span><br>                     .Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();<br>             }, "The Publisher under test only supports 1 subscribers, while this test requires at least 2 to run");<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class Spec104WaitingVerification : IdentityProcessorVerification<int><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br>             /// </summary><br><span style="color:orangered;">-            public Spec104WaitingVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public Spec104WaitingVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -107,18 +113,17 @@ public void Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo</span><br>         {<br>             RequireTestFailure(() =><br>             {<br><span style="color:orangered;">-                new Spec104WaitingVerification(NewTestEnvironment(), DefaultTimeoutMilliseconds)</span><br><span style="color:green;">+                new Spec104WaitingVerification(NewTestEnvironment(_output), DefaultTimeoutMilliseconds)</span><br>                     .Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();<br>             }, "Did not receive expected error on downstream within " + DefaultTimeoutMilliseconds);<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class Spec104IgnoreVerification : IdentityProcessorVerification<int><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br>             /// </summary><br><span style="color:orangered;">-            public Spec104IgnoreVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public Spec104IgnoreVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -139,8 +144,8 @@ public Spec104IgnoreVerification(TestEnvironment environment) : base(environment</span><br>             public override long MaxSupportedSubscribers { get; } = 1;<br>         }<br> <br><span style="color:orangered;">-        private static TestEnvironment NewTestEnvironment()</span><br><span style="color:orangered;">-            => new TestEnvironment(DefaultTimeoutMilliseconds, DefaultNoSignalsTimeoutMilliseconds);</span><br><span style="color:green;">+        private static TestEnvironment NewTestEnvironment(ITestOutputHelper output)</span><br><span style="color:green;">+            => new TestEnvironment(DefaultTimeoutMilliseconds, DefaultNoSignalsTimeoutMilliseconds, output);</span><br> <br> <br>         // FAILING IMPLEMENTATIONS //<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 37d1ac7..5ccef7f 100644<br><span style="color:blue;">@@ -7,6 +7,7 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     public class IdentityProcessorVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:blue;">@@ -25,13 +26,13 @@ public void Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo</span><br>             }, "The Publisher under test only supports 1 subscribers, while this test requires at least 2 to run");<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br><span style="color:orangered;">-        private sealed class Spec104WaitingVerification : IdentityProcessorVerification<int></span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class Spec104WaitingVerification : IdentityProcessorVerification<int></span><br><span style="color:green;">+</span><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br>             /// </summary><br><span style="color:orangered;">-            public Spec104WaitingVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public Spec104WaitingVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -100,6 +101,7 @@ public Spec104WaitingVerification(TestEnvironment environment, long publisherRef</span><br>             public override IPublisher<int> CreateHelperPublisher(long elements) => new Publisher();<br> <br>             public override IPublisher<int> CreateFailedPublisher() => null;<br><span style="color:green;">+</span><br>         }<br> <br>         [SkippableFact]<br><span style="color:blue;">@@ -173,4 +175,5 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index d53b911..5ccef7f 100644<br><span style="color:blue;">@@ -1,12 +1,13 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     public class IdentityProcessorVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:blue;">@@ -15,24 +16,18 @@ public class IdentityProcessorVerificationTest : TCKVerificationSupport</span><br>         private static readonly long DefaultNoSignalsTimeoutMilliseconds =<br>             TestEnvironment.EnvironmentDefaultNoSignalsTimeoutMilliseconds();<br> <br><span style="color:orangered;">-        private readonly ITestOutputHelper _output;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public IdentityProcessorVerificationTest(ITestOutputHelper output)</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            _output = output;</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br>         [SkippableFact]<br>         public void Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError_shouldBeIgnored()<br>         {<br>             RequireTestSkip(() =><br>             {<br><span style="color:orangered;">-                new Spec104IgnoreVerification(NewTestEnvironment(_output))</span><br><span style="color:green;">+                new Spec104IgnoreVerification(NewTestEnvironment())</span><br>                     .Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();<br>             }, "The Publisher under test only supports 1 subscribers, while this test requires at least 2 to run");<br>         }<br> <br><span style="color:orangered;">-        private sealed class Spec104WaitingVerification : IdentityProcessorVerification<int></span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class Spec104WaitingVerification : IdentityProcessorVerification<int></span><br><span style="color:green;">+</span><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br><span style="color:blue;">@@ -106,6 +101,7 @@ public Spec104WaitingVerification(TestEnvironment environment, long publisherRef</span><br>             public override IPublisher<int> CreateHelperPublisher(long elements) => new Publisher();<br> <br>             public override IPublisher<int> CreateFailedPublisher() => null;<br><span style="color:green;">+</span><br>         }<br> <br>         [SkippableFact]<br><span style="color:blue;">@@ -113,17 +109,18 @@ public void Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo</span><br>         {<br>             RequireTestFailure(() =><br>             {<br><span style="color:orangered;">-                new Spec104WaitingVerification(NewTestEnvironment(_output), DefaultTimeoutMilliseconds)</span><br><span style="color:green;">+                new Spec104WaitingVerification(NewTestEnvironment(), DefaultTimeoutMilliseconds)</span><br>                     .Required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();<br>             }, "Did not receive expected error on downstream within " + DefaultTimeoutMilliseconds);<br>         }<br> <br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class Spec104IgnoreVerification : IdentityProcessorVerification<int><br>         {<br>             /// <summary><br>             /// We need this constructor for NUnit even if the fixture is ignored <br>             /// </summary><br><span style="color:orangered;">-            public Spec104IgnoreVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            public Spec104IgnoreVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -144,8 +141,8 @@ public Spec104IgnoreVerification(TestEnvironment environment) : base(environment</span><br>             public override long MaxSupportedSubscribers { get; } = 1;<br>         }<br> <br><span style="color:orangered;">-        private static TestEnvironment NewTestEnvironment(ITestOutputHelper output)</span><br><span style="color:orangered;">-            => new TestEnvironment(DefaultTimeoutMilliseconds, DefaultNoSignalsTimeoutMilliseconds, output);</span><br><span style="color:green;">+        private static TestEnvironment NewTestEnvironment()</span><br><span style="color:green;">+            => new TestEnvironment(DefaultTimeoutMilliseconds, DefaultNoSignalsTimeoutMilliseconds);</span><br> <br> <br>         // FAILING IMPLEMENTATIONS //<br><span style="color:blue;">@@ -178,4 +175,5 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\SubscriberBlackboxVerificationTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 7c6a122..24982bf 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br><span style="color:blue;">@@ -12,9 +12,15 @@ namespace Reactive.Streams.TCK.Tests</span><br>     /// Validates that the TCK's <see cref="SubscriberBlackboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:orangered;">-    </span><br>     public class SubscriberBlackboxVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public SubscriberBlackboxVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>             => RequireTestFailure(<br><span style="color:blue;">@@ -138,13 +144,11 @@ public void Required_spec213_blackbox_mustThrowNullPointerExceptionWhenParameter</span><br>         /// Verification using a Subscriber that doesn't do anything on any of the callbacks<br>         /// </summary><br>         private SubscriberBlackboxVerification<int> NoopSubscriberVerification()<br><span style="color:orangered;">-            => new NoopBlackboxVerification(new TestEnvironment());</span><br><span style="color:green;">+            => new NoopBlackboxVerification(new TestEnvironment(_output));</span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class NoopBlackboxVerification : SubscriberBlackboxVerification<int><br>         {<br><span style="color:orangered;">-            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:orangered;">-            public NoopBlackboxVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public NoopBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -162,13 +166,11 @@ public NoopBlackboxVerification(TestEnvironment environment) : base(environment)</span><br>         /// Verification using a Subscriber that only calls 'Requests(1)' on 'OnSubscribe' and 'OnNext'<br>         /// </summary><br>         private SubscriberBlackboxVerification<int> SimpleSubscriberVerification()<br><span style="color:orangered;">-            => new SimpleBlackboxVerification(new TestEnvironment());</span><br><span style="color:green;">+            => new SimpleBlackboxVerification(new TestEnvironment(_output));</span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class SimpleBlackboxVerification : SubscriberBlackboxVerification<int><br>         {<br><span style="color:orangered;">-            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:orangered;">-            public SimpleBlackboxVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public SimpleBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -196,15 +198,13 @@ public override ISubscriber<int> CreateSubscriber()</span><br>         /// Custom Verification using given Subscriber<br>         /// </summary><br>         private SubscriberBlackboxVerification<int?> CustomSubscriberVerification(ISubscriber<int?> subscriber)<br><span style="color:orangered;">-            => new CustomBlackboxVerification(new TestEnvironment(), subscriber);</span><br><span style="color:green;">+            => new CustomBlackboxVerification(new TestEnvironment(_output), subscriber);</span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class CustomBlackboxVerification : SubscriberBlackboxVerification<int?><br>         {<br>             private readonly ISubscriber<int?> _subscriber;<br> <br><span style="color:orangered;">-            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:orangered;">-            public CustomBlackboxVerification() : base(new TestEnvironment())</span><br><span style="color:green;">+            public CustomBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>             {<br> <br>             }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 7c6a122..c2c254b 100644<br><span style="color:blue;">@@ -7,14 +7,22 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     /// <summary><br>     /// Validates that the TCK's <see cref="SubscriberBlackboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:orangered;">-    </span><br><span style="color:green;">+</span><br>     public class SubscriberBlackboxVerificationTest : TCKVerificationSupport<br><span style="color:green;">+</span><br>     {<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public SubscriberBlackboxVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br>         [SkippableFact]<br>         public void Required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>             => RequireTestFailure(<br><span style="color:blue;">@@ -137,11 +145,12 @@ public void Required_spec213_blackbox_mustThrowNullPointerExceptionWhenParameter</span><br>         /// <summary><br>         /// Verification using a Subscriber that doesn't do anything on any of the callbacks<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberBlackboxVerification<int> NoopSubscriberVerification()<br><span style="color:orangered;">-            => new NoopBlackboxVerification(new TestEnvironment());</span><br><span style="color:green;">+            => new NoopBlackboxVerification(new TestEnvironment(_output));</span><br><span style="color:green;">+</span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class NoopBlackboxVerification : SubscriberBlackboxVerification<int></span><br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br><span style="color:orangered;">-        private sealed class NoopBlackboxVerification : SubscriberBlackboxVerification<int></span><br>         {<br>             //Requirement for NUnit even if the tests are ignored<br>             public NoopBlackboxVerification() : base(new TestEnvironment())<br><span style="color:blue;">@@ -156,6 +165,7 @@ public NoopBlackboxVerification(TestEnvironment environment) : base(environment)</span><br>             public override int CreateElement(int element) => element;<br> <br>             public override ISubscriber<int> CreateSubscriber() => new LamdaSubscriber<int>();<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -164,8 +174,8 @@ public NoopBlackboxVerification(TestEnvironment environment) : base(environment)</span><br>         private SubscriberBlackboxVerification<int> SimpleSubscriberVerification()<br>             => new SimpleBlackboxVerification(new TestEnvironment());<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper verification for single test")]</span><br><span style="color:orangered;">-        private sealed class SimpleBlackboxVerification : SubscriberBlackboxVerification<int></span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class SimpleBlackboxVerification : SubscriberBlackboxVerification<int></span><br><span style="color:green;">+</span><br>         {<br>             //Requirement for NUnit even if the tests are ignored<br>             public SimpleBlackboxVerification() : base(new TestEnvironment())<br><span style="color:blue;">@@ -190,6 +200,7 @@ public override ISubscriber<int> CreateSubscriber()</span><br>                     },<br>                     onNext: _ => sub.Request(1));<br>             }<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -218,5 +229,7 @@ public CustomBlackboxVerification(TestEnvironment environment, ISubscriber<int?></span><br> <br>             public override ISubscriber<int?> CreateSubscriber() => _subscriber;<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 24982bf..c2c254b 100644<br><span style="color:blue;">@@ -1,18 +1,21 @@</span><br> /***************************************************<br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:green;">+ * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+ ***************************************************/</span><br> using System;<br> using Xunit;<br> using Xunit.Abstractions;<br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br>     /// <summary><br>     /// Validates that the TCK's <see cref="SubscriberBlackboxVerification{T}"/> fails with nice human readable errors.<br>     /// >Important: Please note that all Publishers implemented in this file are *wrong*!<br>     /// </summary><br><span style="color:green;">+</span><br>     public class SubscriberBlackboxVerificationTest : TCKVerificationSupport<br><span style="color:green;">+</span><br>     {<br>         private readonly ITestOutputHelper _output;<br> <br><span style="color:blue;">@@ -20,7 +23,6 @@ public SubscriberBlackboxVerificationTest(ITestOutputHelper output)</span><br>         {<br>             _output = output;<br>         }<br><span style="color:orangered;">-</span><br>         [SkippableFact]<br>         public void Required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest_shouldFailBy_notGettingRequestCall()<br>             => RequireTestFailure(<br><span style="color:blue;">@@ -143,12 +145,15 @@ public void Required_spec213_blackbox_mustThrowNullPointerExceptionWhenParameter</span><br>         /// <summary><br>         /// Verification using a Subscriber that doesn't do anything on any of the callbacks<br>         /// </summary><br><span style="color:green;">+</span><br>         private SubscriberBlackboxVerification<int> NoopSubscriberVerification()<br>             => new NoopBlackboxVerification(new TestEnvironment(_output));<br> <br><span style="color:orangered;">-        private sealed class NoopBlackboxVerification : SubscriberBlackboxVerification<int></span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class NoopBlackboxVerification : SubscriberBlackboxVerification<int></span><br><span style="color:green;">+</span><br>         {<br><span style="color:orangered;">-            public NoopBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:green;">+            public NoopBlackboxVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -160,17 +165,20 @@ public NoopBlackboxVerification(TestEnvironment environment) : base(environment)</span><br>             public override int CreateElement(int element) => element;<br> <br>             public override ISubscriber<int> CreateSubscriber() => new LamdaSubscriber<int>();<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br>         /// Verification using a Subscriber that only calls 'Requests(1)' on 'OnSubscribe' and 'OnNext'<br>         /// </summary><br>         private SubscriberBlackboxVerification<int> SimpleSubscriberVerification()<br><span style="color:orangered;">-            => new SimpleBlackboxVerification(new TestEnvironment(_output));</span><br><span style="color:green;">+            => new SimpleBlackboxVerification(new TestEnvironment());</span><br><span style="color:green;">+</span><br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")] private sealed class SimpleBlackboxVerification : SubscriberBlackboxVerification<int></span><br> <br><span style="color:orangered;">-        private sealed class SimpleBlackboxVerification : SubscriberBlackboxVerification<int></span><br>         {<br><span style="color:orangered;">-            public SimpleBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:green;">+            public SimpleBlackboxVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -192,19 +200,22 @@ public override ISubscriber<int> CreateSubscriber()</span><br>                     },<br>                     onNext: _ => sub.Request(1));<br>             }<br><span style="color:green;">+</span><br>         }<br> <br>         /// <summary><br>         /// Custom Verification using given Subscriber<br>         /// </summary><br>         private SubscriberBlackboxVerification<int?> CustomSubscriberVerification(ISubscriber<int?> subscriber)<br><span style="color:orangered;">-            => new CustomBlackboxVerification(new TestEnvironment(_output), subscriber);</span><br><span style="color:green;">+            => new CustomBlackboxVerification(new TestEnvironment(), subscriber);</span><br> <br><span style="color:green;">+        [TestFixture(Ignore = "Helper verification for single test")]</span><br>         private sealed class CustomBlackboxVerification : SubscriberBlackboxVerification<int?><br>         {<br>             private readonly ISubscriber<int?> _subscriber;<br> <br><span style="color:orangered;">-            public CustomBlackboxVerification(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:green;">+            //Requirement for NUnit even if the tests are ignored</span><br><span style="color:green;">+            public CustomBlackboxVerification() : base(new TestEnvironment())</span><br>             {<br> <br>             }<br><span style="color:blue;">@@ -218,5 +229,7 @@ public CustomBlackboxVerification(TestEnvironment environment, ISubscriber<int?></span><br> <br>             public override ISubscriber<int?> CreateSubscriber() => _subscriber;<br>         }<br><span style="color:green;">+</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\RangePublisherTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 5f909f5..de61f25 100644<br><span style="color:blue;">@@ -1,6 +1,6 @@</span><br> /***************************************************<br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:green;">+* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:green;">+***************************************************/</span><br> using Xunit;<br> using Xunit.Abstractions;<br> using System;<br><span style="color:blue;">@@ -14,7 +14,7 @@</span><br> <br> namespace Reactive.Streams.TCK.Tests<br> {<br><span style="color:orangered;">-    </span><br><span style="color:green;">+    //[TestFixture]</span><br>     public class RangePublisherTest : PublisherVerification<int>, IDisposable<br>     {<br>         static readonly ConcurrentDictionary<int, string> stacks = new ConcurrentDictionary<int, string>();<br><span style="color:blue;">@@ -23,30 +23,7 @@ public class RangePublisherTest : PublisherVerification<int>, IDisposable</span><br> <br>         static int id;<br> <br><span style="color:orangered;">-        public void Dispose()</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            bool fail = false;</span><br><span style="color:orangered;">-            StringBuilder b = new StringBuilder();</span><br><span style="color:orangered;">-            foreach (var t in states)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                if (!t.Value)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    b.Append("\r\n-------------------------------");</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    b.Append("\r\nat ").Append(stacks[t.Key]);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    fail = true;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-            states.Clear();</span><br><span style="color:orangered;">-            stacks.Clear();</span><br><span style="color:orangered;">-            if (fail)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                throw new InvalidOperationException("Cancellations were missing:" + b);</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public RangePublisherTest() : base(new TestEnvironment())</span><br><span style="color:green;">+        public RangePublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -191,5 +168,28 @@ public void Cancel()</span><br>                 }<br>             }<br>         }<br><span style="color:green;">+</span><br><span style="color:green;">+        public void Dispose()</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            bool fail = false;</span><br><span style="color:green;">+            StringBuilder b = new StringBuilder();</span><br><span style="color:green;">+            foreach (var t in states)</span><br><span style="color:green;">+            {</span><br><span style="color:green;">+                if (!t.Value)</span><br><span style="color:green;">+                {</span><br><span style="color:green;">+                    b.Append("\r\n-------------------------------");</span><br><span style="color:green;">+</span><br><span style="color:green;">+                    b.Append("\r\nat ").Append(stacks[t.Key]);</span><br><span style="color:green;">+</span><br><span style="color:green;">+                    fail = true;</span><br><span style="color:green;">+                }</span><br><span style="color:green;">+            }</span><br><span style="color:green;">+            states.Clear();</span><br><span style="color:green;">+            stacks.Clear();</span><br><span style="color:green;">+            if (fail)</span><br><span style="color:green;">+            {</span><br><span style="color:green;">+                throw new InvalidOperationException("Cancellations were missing:" + b);</span><br><span style="color:green;">+            }</span><br><span style="color:green;">+        }</span><br>     }<br> }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 5f909f5..e69de29 100644<br><span style="color:blue;">@@ -1,195 +0,0 @@</span><br><span style="color:orangered;">-/***************************************************</span><br><span style="color:orangered;">- * Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">- ***************************************************/</span><br><span style="color:orangered;">-using Xunit;</span><br><span style="color:orangered;">-using Xunit.Abstractions;</span><br><span style="color:orangered;">-using System;</span><br><span style="color:orangered;">-using System.Collections.Concurrent;</span><br><span style="color:orangered;">-using System.Collections.Generic;</span><br><span style="color:orangered;">-using System.Diagnostics;</span><br><span style="color:orangered;">-using System.Linq;</span><br><span style="color:orangered;">-using System.Text;</span><br><span style="color:orangered;">-using System.Threading;</span><br><span style="color:orangered;">-using System.Threading.Tasks;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-namespace Reactive.Streams.TCK.Tests</span><br><span style="color:orangered;">-{</span><br><span style="color:orangered;">-    </span><br><span style="color:orangered;">-    public class RangePublisherTest : PublisherVerification<int>, IDisposable</span><br><span style="color:orangered;">-    {</span><br><span style="color:orangered;">-        static readonly ConcurrentDictionary<int, string> stacks = new ConcurrentDictionary<int, string>();</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        static readonly ConcurrentDictionary<int, bool> states = new ConcurrentDictionary<int, bool>();</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        static int id;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public void Dispose()</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            bool fail = false;</span><br><span style="color:orangered;">-            StringBuilder b = new StringBuilder();</span><br><span style="color:orangered;">-            foreach (var t in states)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                if (!t.Value)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    b.Append("\r\n-------------------------------");</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    b.Append("\r\nat ").Append(stacks[t.Key]);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    fail = true;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-            states.Clear();</span><br><span style="color:orangered;">-            stacks.Clear();</span><br><span style="color:orangered;">-            if (fail)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                throw new InvalidOperationException("Cancellations were missing:" + b);</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public RangePublisherTest() : base(new TestEnvironment())</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public override IPublisher<int> CreatePublisher(long elements)</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            return new RangePublisher(1, elements);</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public override IPublisher<int> CreateFailedPublisher()</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            return null;</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        internal sealed class RangePublisher : IPublisher<int></span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly string stacktrace;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly long start;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly long count;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            internal RangePublisher(long start, long count)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                this.stacktrace = Environment.StackTrace;</span><br><span style="color:orangered;">-                this.start = start;</span><br><span style="color:orangered;">-                this.count = count;</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            public void Subscribe(ISubscriber<int> s)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                if (s == null)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    throw new ArgumentNullException();</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                int ids = Interlocked.Increment(ref id);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                RangeSubscription parent = new RangeSubscription(s, ids, start, start + count);</span><br><span style="color:orangered;">-                stacks.AddOrUpdate(ids, (a) => stacktrace, (a, b) => stacktrace);</span><br><span style="color:orangered;">-                states.AddOrUpdate(ids, (a) => false, (a, b) => false);</span><br><span style="color:orangered;">-                s.OnSubscribe(parent);</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            sealed class RangeSubscription : ISubscription</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly ISubscriber<int> actual;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly int ids;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly long end;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                long index;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                volatile bool cancelled;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                long requested;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                internal RangeSubscription(ISubscriber<int> actual, int ids, long start, long end)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    this.actual = actual;</span><br><span style="color:orangered;">-                    this.ids = ids;</span><br><span style="color:orangered;">-                    this.index = start;</span><br><span style="color:orangered;">-                    this.end = end;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                public void Request(long n)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    if (!cancelled)</span><br><span style="color:orangered;">-                    {</span><br><span style="color:orangered;">-                        if (n <= 0L)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            cancelled = true;</span><br><span style="color:orangered;">-                            states[ids] = true;</span><br><span style="color:orangered;">-                            actual.OnError(new ArgumentException("ยง3.9 violated"));</span><br><span style="color:orangered;">-                            return;</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        for (;;)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            long r = Volatile.Read(ref requested);</span><br><span style="color:orangered;">-                            long u = r + n;</span><br><span style="color:orangered;">-                            if (u < 0L)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                u = long.MaxValue;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                            if (Interlocked.CompareExchange(ref requested, u, r) == r)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (r == 0)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    break;</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-                                return;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        long idx = index;</span><br><span style="color:orangered;">-                        long f = end;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        for (;;)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            long e = 0;</span><br><span style="color:orangered;">-                            while (e != n && idx != f)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (cancelled)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    return;</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                                actual.OnNext((int)idx);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                                idx++;</span><br><span style="color:orangered;">-                                e++;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                            if (idx == f)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (!cancelled)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    states[ids] = true;</span><br><span style="color:orangered;">-                                    actual.OnComplete();</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-                                return;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                            index = idx;</span><br><span style="color:orangered;">-                            n = Interlocked.Add(ref requested, -n);</span><br><span style="color:orangered;">-                            if (n == 0)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                break;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-                    }</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                public void Cancel()</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    cancelled = true;</span><br><span style="color:orangered;">-                    states[ids] = true;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-    }</span><br><span style="color:orangered;">-}</span><br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index de61f25..e69de29 100644<br><span style="color:blue;">@@ -1,195 +0,0 @@</span><br><span style="color:orangered;">-/***************************************************</span><br><span style="color:orangered;">-* Licensed under MIT No Attribution (SPDX: MIT-0) *</span><br><span style="color:orangered;">-***************************************************/</span><br><span style="color:orangered;">-using Xunit;</span><br><span style="color:orangered;">-using Xunit.Abstractions;</span><br><span style="color:orangered;">-using System;</span><br><span style="color:orangered;">-using System.Collections.Concurrent;</span><br><span style="color:orangered;">-using System.Collections.Generic;</span><br><span style="color:orangered;">-using System.Diagnostics;</span><br><span style="color:orangered;">-using System.Linq;</span><br><span style="color:orangered;">-using System.Text;</span><br><span style="color:orangered;">-using System.Threading;</span><br><span style="color:orangered;">-using System.Threading.Tasks;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-namespace Reactive.Streams.TCK.Tests</span><br><span style="color:orangered;">-{</span><br><span style="color:orangered;">-    //[TestFixture]</span><br><span style="color:orangered;">-    public class RangePublisherTest : PublisherVerification<int>, IDisposable</span><br><span style="color:orangered;">-    {</span><br><span style="color:orangered;">-        static readonly ConcurrentDictionary<int, string> stacks = new ConcurrentDictionary<int, string>();</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        static readonly ConcurrentDictionary<int, bool> states = new ConcurrentDictionary<int, bool>();</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        static int id;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public RangePublisherTest(ITestOutputHelper output) : base(new TestEnvironment(output))</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public override IPublisher<int> CreatePublisher(long elements)</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            return new RangePublisher(1, elements);</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public override IPublisher<int> CreateFailedPublisher()</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            return null;</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        internal sealed class RangePublisher : IPublisher<int></span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly string stacktrace;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly long start;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            readonly long count;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            internal RangePublisher(long start, long count)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                this.stacktrace = Environment.StackTrace;</span><br><span style="color:orangered;">-                this.start = start;</span><br><span style="color:orangered;">-                this.count = count;</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            public void Subscribe(ISubscriber<int> s)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                if (s == null)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    throw new ArgumentNullException();</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                int ids = Interlocked.Increment(ref id);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                RangeSubscription parent = new RangeSubscription(s, ids, start, start + count);</span><br><span style="color:orangered;">-                stacks.AddOrUpdate(ids, (a) => stacktrace, (a, b) => stacktrace);</span><br><span style="color:orangered;">-                states.AddOrUpdate(ids, (a) => false, (a, b) => false);</span><br><span style="color:orangered;">-                s.OnSubscribe(parent);</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            sealed class RangeSubscription : ISubscription</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly ISubscriber<int> actual;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly int ids;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                readonly long end;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                long index;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                volatile bool cancelled;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                long requested;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                internal RangeSubscription(ISubscriber<int> actual, int ids, long start, long end)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    this.actual = actual;</span><br><span style="color:orangered;">-                    this.ids = ids;</span><br><span style="color:orangered;">-                    this.index = start;</span><br><span style="color:orangered;">-                    this.end = end;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                public void Request(long n)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    if (!cancelled)</span><br><span style="color:orangered;">-                    {</span><br><span style="color:orangered;">-                        if (n <= 0L)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            cancelled = true;</span><br><span style="color:orangered;">-                            states[ids] = true;</span><br><span style="color:orangered;">-                            actual.OnError(new ArgumentException("ยง3.9 violated"));</span><br><span style="color:orangered;">-                            return;</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        for (;;)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            long r = Volatile.Read(ref requested);</span><br><span style="color:orangered;">-                            long u = r + n;</span><br><span style="color:orangered;">-                            if (u < 0L)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                u = long.MaxValue;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                            if (Interlocked.CompareExchange(ref requested, u, r) == r)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (r == 0)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    break;</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-                                return;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        long idx = index;</span><br><span style="color:orangered;">-                        long f = end;</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                        for (;;)</span><br><span style="color:orangered;">-                        {</span><br><span style="color:orangered;">-                            long e = 0;</span><br><span style="color:orangered;">-                            while (e != n && idx != f)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (cancelled)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    return;</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                                actual.OnNext((int)idx);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                                idx++;</span><br><span style="color:orangered;">-                                e++;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                            if (idx == f)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                if (!cancelled)</span><br><span style="color:orangered;">-                                {</span><br><span style="color:orangered;">-                                    states[ids] = true;</span><br><span style="color:orangered;">-                                    actual.OnComplete();</span><br><span style="color:orangered;">-                                }</span><br><span style="color:orangered;">-                                return;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                            index = idx;</span><br><span style="color:orangered;">-                            n = Interlocked.Add(ref requested, -n);</span><br><span style="color:orangered;">-                            if (n == 0)</span><br><span style="color:orangered;">-                            {</span><br><span style="color:orangered;">-                                break;</span><br><span style="color:orangered;">-                            }</span><br><span style="color:orangered;">-                        }</span><br><span style="color:orangered;">-                    }</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                public void Cancel()</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    cancelled = true;</span><br><span style="color:orangered;">-                    states[ids] = true;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        public void Dispose()</span><br><span style="color:orangered;">-        {</span><br><span style="color:orangered;">-            bool fail = false;</span><br><span style="color:orangered;">-            StringBuilder b = new StringBuilder();</span><br><span style="color:orangered;">-            foreach (var t in states)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                if (!t.Value)</span><br><span style="color:orangered;">-                {</span><br><span style="color:orangered;">-                    b.Append("\r\n-------------------------------");</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    b.Append("\r\nat ").Append(stacks[t.Key]);</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    fail = true;</span><br><span style="color:orangered;">-                }</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-            states.Clear();</span><br><span style="color:orangered;">-            stacks.Clear();</span><br><span style="color:orangered;">-            if (fail)</span><br><span style="color:orangered;">-            {</span><br><span style="color:orangered;">-                throw new InvalidOperationException("Cancellations were missing:" + b);</span><br><span style="color:orangered;">-            }</span><br><span style="color:orangered;">-        }</span><br><span style="color:orangered;">-    }</span><br><span style="color:orangered;">-}</span><br><hr><h1>src\tck\Reactive.Streams.TCK\TestEnvironment.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 03d5900..34db067 100644<br><span style="color:blue;">@@ -18,6 +18,7 @@ public class TestEnvironment</span><br>         private const long DefaultTimeoutMillis = 500;<br>         private const string DefaultNoSignalsTimeoutMillisEnv = "DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS";<br>         <br><span style="color:green;">+        public ITestOutputHelper Output { get; }</span><br> <br>         /// <summary><br>         /// Tests must specify the timeout for expected outcome of asynchronous<br><span style="color:blue;">@@ -27,12 +28,12 @@ public class TestEnvironment</span><br>         /// </summary><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br>         /// <param name="defaultNoSignalsTimeoutMilliseconds">default timeout to be used when no further signals are expected anymore</param><br><span style="color:orangered;">-        /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output. Default: false</param></span><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds)</span><br><span style="color:green;">+        /// <param name="output">if not null, signals such as OnNext / Request / OnComplete etc will be printed to standard output. Default: null</param></span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds, ITestOutputHelper output = null)</span><br>         {<br>             DefaultTimeoutMilliseconds = defaultTimeoutMilliseconds;<br>             DefaultNoSignalsTimeoutMilliseconds = defaultNoSignalsTimeoutMilliseconds;<br><span style="color:orangered;">-            WriteLineDebug = writeLineDebug;</span><br><span style="color:green;">+            Output = output;</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -42,8 +43,11 @@ public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTim</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds)</span><br><span style="color:orangered;">-            : this(defaultTimeoutMilliseconds, defaultTimeoutMilliseconds)</span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, ITestOutputHelper output)</span><br><span style="color:green;">+            : this(</span><br><span style="color:green;">+                defaultTimeoutMilliseconds,</span><br><span style="color:green;">+                defaultTimeoutMilliseconds,</span><br><span style="color:green;">+                output)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -54,10 +58,11 @@ public TestEnvironment(long defaultTimeoutMilliseconds)</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output</param><br><span style="color:orangered;">-        public TestEnvironment(bool writeLineDebug)</span><br><span style="color:green;">+        public TestEnvironment(bool writeLineDebug, ITestOutputHelper output)</span><br>             : this(<br>                 EnvironmentDefaultTimeoutMilliseconds(),<br><span style="color:orangered;">-                EnvironmentDefaultNoSignalsTimeoutMilliseconds())</span><br><span style="color:green;">+                EnvironmentDefaultNoSignalsTimeoutMilliseconds(), </span><br><span style="color:green;">+                output)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -67,8 +72,11 @@ public TestEnvironment(bool writeLineDebug)</span><br>         /// the implementation, but can in some cases result in longer time to<br>         /// run the tests.<br>         /// </summary><br><span style="color:orangered;">-        public TestEnvironment()</span><br><span style="color:orangered;">-            : this(EnvironmentDefaultTimeoutMilliseconds(), EnvironmentDefaultNoSignalsTimeoutMilliseconds())</span><br><span style="color:green;">+        public TestEnvironment(ITestOutputHelper output)</span><br><span style="color:green;">+            : this(</span><br><span style="color:green;">+                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:green;">+                EnvironmentDefaultNoSignalsTimeoutMilliseconds(),</span><br><span style="color:green;">+                output)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -83,11 +91,6 @@ public TestEnvironment()</span><br>         /// </summary><br>         public long DefaultNoSignalsTimeoutMilliseconds { get; }<br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:orangered;">-        /// If true, signals such as OnNext / Request / OnComplete etc will be printed to standard output</span><br><span style="color:orangered;">-        /// </summary></span><br><span style="color:orangered;">-        </span><br><span style="color:orangered;">-</span><br>         public ConcurrentQueue<Exception> AsyncErrors { get; } = new ConcurrentQueue<Exception>();<br> <br>         /// <summary><br><span style="color:blue;">@@ -314,11 +317,11 @@ public void VerifyNoAsyncErrorsNoDelay()</span><br>         }<br> <br>         /// <summary><br><span style="color:orangered;">-        /// If <see cref="WriteLineDebug"/> is true, print debug message to std out.</span><br><span style="color:green;">+        /// If <see cref="Output"/> is not null, print debug message to std out.</span><br>         /// </summary><br>         public void Debug(string message)<br>         {<br><span style="color:orangered;">-                        Console.WriteLine($"[TCK-DEBUG] {message}");</span><br><span style="color:green;">+            Output?.WriteLine($"[TCK-DEBUG] {message}");</span><br>         }<br> <br>         /// <summary><br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 03d5900..0f5dad5 100644<br><span style="color:blue;">@@ -10,14 +10,16 @@</span><br> using Reactive.Streams.TCK.Support;<br> <br> namespace Reactive.Streams.TCK<br><span style="color:green;">+</span><br> {<br>     public class TestEnvironment<br>     {<br><span style="color:green;">+        private const long DefaultTimeoutMillis = 500;</span><br>         public const int TestBufferSize = 16;<br>         private const string DefaultTimeoutMillisEnv = "DEFAULT_TIMEOUT_MILLIS";<br><span style="color:orangered;">-        private const long DefaultTimeoutMillis = 500;</span><br><span style="color:green;">+        public ITestOutputHelper Output { get; }</span><br>         private const string DefaultNoSignalsTimeoutMillisEnv = "DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS";<br><span style="color:orangered;">-        </span><br><span style="color:green;">+</span><br> <br>         /// <summary><br>         /// Tests must specify the timeout for expected outcome of asynchronous<br><span style="color:blue;">@@ -28,11 +30,10 @@ public class TestEnvironment</span><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br>         /// <param name="defaultNoSignalsTimeoutMilliseconds">default timeout to be used when no further signals are expected anymore</param><br>         /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output. Default: false</param><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds)</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, ITestOutputHelper output)</span><br><span style="color:green;">+            : this(defaultTimeoutMilliseconds, defaultTimeoutMilliseconds, output)</span><br>         {<br><span style="color:orangered;">-            DefaultTimeoutMilliseconds = defaultTimeoutMilliseconds;</span><br><span style="color:orangered;">-            DefaultNoSignalsTimeoutMilliseconds = defaultNoSignalsTimeoutMilliseconds;</span><br><span style="color:orangered;">-            WriteLineDebug = writeLineDebug;</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -42,8 +43,12 @@ public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTim</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds)</span><br><span style="color:orangered;">-            : this(defaultTimeoutMilliseconds, defaultTimeoutMilliseconds)</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(bool writeLineDebug, ITestOutputHelper output)</span><br><span style="color:green;">+            : this(</span><br><span style="color:green;">+                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:green;">+                EnvironmentDefaultNoSignalsTimeoutMilliseconds(),</span><br><span style="color:green;">+                output)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -54,10 +59,9 @@ public TestEnvironment(long defaultTimeoutMilliseconds)</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output</param><br><span style="color:orangered;">-        public TestEnvironment(bool writeLineDebug)</span><br><span style="color:orangered;">-            : this(</span><br><span style="color:orangered;">-                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:orangered;">-                EnvironmentDefaultNoSignalsTimeoutMilliseconds())</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment()</span><br><span style="color:green;">+            : this(EnvironmentDefaultTimeoutMilliseconds(), EnvironmentDefaultNoSignalsTimeoutMilliseconds(), null)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -67,9 +71,12 @@ public TestEnvironment(bool writeLineDebug)</span><br>         /// the implementation, but can in some cases result in longer time to<br>         /// run the tests.<br>         /// </summary><br><span style="color:orangered;">-        public TestEnvironment()</span><br><span style="color:orangered;">-            : this(EnvironmentDefaultTimeoutMilliseconds(), EnvironmentDefaultNoSignalsTimeoutMilliseconds())</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds, ITestOutputHelper output)</span><br>         {<br><span style="color:green;">+            DefaultTimeoutMilliseconds = defaultTimeoutMilliseconds;</span><br><span style="color:green;">+            DefaultNoSignalsTimeoutMilliseconds = defaultNoSignalsTimeoutMilliseconds;</span><br><span style="color:green;">+            Output = output;</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -86,7 +93,7 @@ public TestEnvironment()</span><br>         /// <summary><br>         /// If true, signals such as OnNext / Request / OnComplete etc will be printed to standard output<br>         /// </summary><br><span style="color:orangered;">-        </span><br><span style="color:green;">+</span><br> <br>         public ConcurrentQueue<Exception> AsyncErrors { get; } = new ConcurrentQueue<Exception>();<br> <br><span style="color:blue;">@@ -146,11 +153,12 @@ public static long EnvironmentDefaultNoSignalsTimeoutMilliseconds()</span><br>         /// <br>         ///  To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception ex)<br>             {<br><span style="color:blue;">@@ -170,11 +178,12 @@ public void Flop(string message)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(Exception exception, string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message, exception);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception)<br>             {<br><span style="color:blue;">@@ -194,15 +203,16 @@ public void Flop(Exception exception, string message)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(Exception exception)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(exception.Message, exception);</span><br><span style="color:green;">+                Assert.False(true, exception.Message);</span><br>             }<br>             catch (Exception)<br>             {<br><span style="color:orangered;">-                AsyncErrors.Enqueue(exception);</span><br><span style="color:green;">+                Output?.WriteLine(exception.Message);</span><br>             }<br>         }<br> <br><span style="color:blue;">@@ -218,16 +228,18 @@ public void Flop(Exception exception)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public T FlopAndFail<T>(string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception ex)<br>             {<br>                 AsyncErrors.Enqueue(ex);<br><span style="color:orangered;">-                TckAssert.Fail(message, ex);</span><br><span style="color:green;">+                Output?.WriteLine(message);</span><br><span style="color:green;">+                Output?.WriteLine(ex.ToString());</span><br>             }<br> <br>             return default(T); // unreachable, the previous block will always exit by throwing<br><span style="color:blue;">@@ -302,6 +314,7 @@ public void VerifyNoAsyncErrors(long delay)</span><br>         /// This version of <see cref="VerifyNoAsyncErrors()"/> <b> does not wait before checking for asynchronous errors </b>, and is to be used<br>         /// for example in tight loops etc.<br>         /// </summary><br><span style="color:green;">+</span><br>         public void VerifyNoAsyncErrorsNoDelay()<br>         {<br>             foreach (var error in AsyncErrors)<br><span style="color:blue;">@@ -309,16 +322,18 @@ public void VerifyNoAsyncErrorsNoDelay()</span><br>                 if (error is AssertionException exception)<br>                     throw exception;<br> <br><span style="color:orangered;">-                TckAssert.Fail($"Async error during test execution: {error.Message}", error);</span><br><span style="color:green;">+                Output?.WriteLine($"Async error during test execution: {error.Message}");</span><br><span style="color:green;">+                Assert.False(true, $"Async error during test execution: {error.Message}");</span><br>             }<br>         }<br> <br>         /// <summary><br>         /// If <see cref="WriteLineDebug"/> is true, print debug message to std out.<br>         /// </summary><br><span style="color:green;">+</span><br>         public void Debug(string message)<br>         {<br><span style="color:orangered;">-                        Console.WriteLine($"[TCK-DEBUG] {message}");</span><br><span style="color:green;">+            Output?.WriteLine($"[TCK-DEBUG] {message}");</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -982,4 +997,5 @@ public ExpectedClosedLatchException(string message) : base(message)</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 34db067..0f5dad5 100644<br><span style="color:blue;">@@ -10,15 +10,16 @@</span><br> using Reactive.Streams.TCK.Support;<br> <br> namespace Reactive.Streams.TCK<br><span style="color:green;">+</span><br> {<br>     public class TestEnvironment<br>     {<br><span style="color:green;">+        private const long DefaultTimeoutMillis = 500;</span><br>         public const int TestBufferSize = 16;<br>         private const string DefaultTimeoutMillisEnv = "DEFAULT_TIMEOUT_MILLIS";<br><span style="color:orangered;">-        private const long DefaultTimeoutMillis = 500;</span><br><span style="color:orangered;">-        private const string DefaultNoSignalsTimeoutMillisEnv = "DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS";</span><br><span style="color:orangered;">-        </span><br>         public ITestOutputHelper Output { get; }<br><span style="color:green;">+        private const string DefaultNoSignalsTimeoutMillisEnv = "DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS";</span><br><span style="color:green;">+</span><br> <br>         /// <summary><br>         /// Tests must specify the timeout for expected outcome of asynchronous<br><span style="color:blue;">@@ -28,12 +29,11 @@ public class TestEnvironment</span><br>         /// </summary><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br>         /// <param name="defaultNoSignalsTimeoutMilliseconds">default timeout to be used when no further signals are expected anymore</param><br><span style="color:orangered;">-        /// <param name="output">if not null, signals such as OnNext / Request / OnComplete etc will be printed to standard output. Default: null</param></span><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds, ITestOutputHelper output = null)</span><br><span style="color:green;">+        /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output. Default: false</param></span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, ITestOutputHelper output)</span><br><span style="color:green;">+            : this(defaultTimeoutMilliseconds, defaultTimeoutMilliseconds, output)</span><br>         {<br><span style="color:orangered;">-            DefaultTimeoutMilliseconds = defaultTimeoutMilliseconds;</span><br><span style="color:orangered;">-            DefaultNoSignalsTimeoutMilliseconds = defaultNoSignalsTimeoutMilliseconds;</span><br><span style="color:orangered;">-            Output = output;</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -43,10 +43,11 @@ public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTim</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="defaultTimeoutMilliseconds">default timeout to be used in all expect* methods</param><br><span style="color:orangered;">-        public TestEnvironment(long defaultTimeoutMilliseconds, ITestOutputHelper output)</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(bool writeLineDebug, ITestOutputHelper output)</span><br>             : this(<br><span style="color:orangered;">-                defaultTimeoutMilliseconds,</span><br><span style="color:orangered;">-                defaultTimeoutMilliseconds,</span><br><span style="color:green;">+                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:green;">+                EnvironmentDefaultNoSignalsTimeoutMilliseconds(),</span><br>                 output)<br>         {<br>         }<br><span style="color:blue;">@@ -58,11 +59,9 @@ public TestEnvironment(long defaultTimeoutMilliseconds, ITestOutputHelper output</span><br>         /// run the tests.<br>         /// </summary><br>         /// <param name="writeLineDebug">if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output</param><br><span style="color:orangered;">-        public TestEnvironment(bool writeLineDebug, ITestOutputHelper output)</span><br><span style="color:orangered;">-            : this(</span><br><span style="color:orangered;">-                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:orangered;">-                EnvironmentDefaultNoSignalsTimeoutMilliseconds(), </span><br><span style="color:orangered;">-                output)</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment()</span><br><span style="color:green;">+            : this(EnvironmentDefaultTimeoutMilliseconds(), EnvironmentDefaultNoSignalsTimeoutMilliseconds(), null)</span><br>         {<br>         }<br> <br><span style="color:blue;">@@ -72,12 +71,12 @@ public TestEnvironment(bool writeLineDebug, ITestOutputHelper output)</span><br>         /// the implementation, but can in some cases result in longer time to<br>         /// run the tests.<br>         /// </summary><br><span style="color:orangered;">-        public TestEnvironment(ITestOutputHelper output)</span><br><span style="color:orangered;">-            : this(</span><br><span style="color:orangered;">-                EnvironmentDefaultTimeoutMilliseconds(),</span><br><span style="color:orangered;">-                EnvironmentDefaultNoSignalsTimeoutMilliseconds(),</span><br><span style="color:orangered;">-                output)</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public TestEnvironment(long defaultTimeoutMilliseconds, long defaultNoSignalsTimeoutMilliseconds, ITestOutputHelper output)</span><br>         {<br><span style="color:green;">+            DefaultTimeoutMilliseconds = defaultTimeoutMilliseconds;</span><br><span style="color:green;">+            DefaultNoSignalsTimeoutMilliseconds = defaultNoSignalsTimeoutMilliseconds;</span><br><span style="color:green;">+            Output = output;</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -91,6 +90,11 @@ public TestEnvironment(ITestOutputHelper output)</span><br>         /// </summary><br>         public long DefaultNoSignalsTimeoutMilliseconds { get; }<br> <br><span style="color:green;">+        /// <summary></span><br><span style="color:green;">+        /// If true, signals such as OnNext / Request / OnComplete etc will be printed to standard output</span><br><span style="color:green;">+        /// </summary></span><br><span style="color:green;">+</span><br><span style="color:green;">+</span><br>         public ConcurrentQueue<Exception> AsyncErrors { get; } = new ConcurrentQueue<Exception>();<br> <br>         /// <summary><br><span style="color:blue;">@@ -149,11 +153,12 @@ public static long EnvironmentDefaultNoSignalsTimeoutMilliseconds()</span><br>         /// <br>         ///  To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception ex)<br>             {<br><span style="color:blue;">@@ -173,11 +178,12 @@ public void Flop(string message)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(Exception exception, string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message, exception);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception)<br>             {<br><span style="color:blue;">@@ -197,15 +203,16 @@ public void Flop(Exception exception, string message)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Flop(Exception exception)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(exception.Message, exception);</span><br><span style="color:green;">+                Assert.False(true, exception.Message);</span><br>             }<br>             catch (Exception)<br>             {<br><span style="color:orangered;">-                AsyncErrors.Enqueue(exception);</span><br><span style="color:green;">+                Output?.WriteLine(exception.Message);</span><br>             }<br>         }<br> <br><span style="color:blue;">@@ -221,16 +228,18 @@ public void Flop(Exception exception)</span><br>         /// <br>         /// To clear asyncErrors you can call <see cref="ClearAsyncErrors"/><br>         /// </summary><br><span style="color:green;">+</span><br>         public T FlopAndFail<T>(string message)<br>         {<br>             try<br>             {<br><span style="color:orangered;">-                TckAssert.Fail(message);</span><br><span style="color:green;">+                Assert.False(true, message);</span><br>             }<br>             catch (Exception ex)<br>             {<br>                 AsyncErrors.Enqueue(ex);<br><span style="color:orangered;">-                TckAssert.Fail(message, ex);</span><br><span style="color:green;">+                Output?.WriteLine(message);</span><br><span style="color:green;">+                Output?.WriteLine(ex.ToString());</span><br>             }<br> <br>             return default(T); // unreachable, the previous block will always exit by throwing<br><span style="color:blue;">@@ -305,6 +314,7 @@ public void VerifyNoAsyncErrors(long delay)</span><br>         /// This version of <see cref="VerifyNoAsyncErrors()"/> <b> does not wait before checking for asynchronous errors </b>, and is to be used<br>         /// for example in tight loops etc.<br>         /// </summary><br><span style="color:green;">+</span><br>         public void VerifyNoAsyncErrorsNoDelay()<br>         {<br>             foreach (var error in AsyncErrors)<br><span style="color:blue;">@@ -312,13 +322,15 @@ public void VerifyNoAsyncErrorsNoDelay()</span><br>                 if (error is AssertionException exception)<br>                     throw exception;<br> <br><span style="color:orangered;">-                TckAssert.Fail($"Async error during test execution: {error.Message}", error);</span><br><span style="color:green;">+                Output?.WriteLine($"Async error during test execution: {error.Message}");</span><br><span style="color:green;">+                Assert.False(true, $"Async error during test execution: {error.Message}");</span><br>             }<br>         }<br> <br>         /// <summary><br><span style="color:orangered;">-        /// If <see cref="Output"/> is not null, print debug message to std out.</span><br><span style="color:green;">+        /// If <see cref="WriteLineDebug"/> is true, print debug message to std out.</span><br>         /// </summary><br><span style="color:green;">+</span><br>         public void Debug(string message)<br>         {<br>             Output?.WriteLine($"[TCK-DEBUG] {message}");<br><span style="color:blue;">@@ -985,4 +997,5 @@ public ExpectedClosedLatchException(string message) : base(message)</span><br>             }<br>         }<br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><hr><h1>src\tck\Reactive.Streams.TCK.Tests\PublisherVerificationTest.cs</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index b0c6908..3f39d56 100644<br><span style="color:blue;">@@ -17,6 +17,13 @@ namespace Reactive.Streams.TCK.Tests</span><br>     /// </summary><br>     public class PublisherVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public PublisherVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br><span style="color:green;">+</span><br>         [SkippableFact]<br>         public void Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements_shouldFailBy_ExpectingOnError()<br>             => RequireTestFailure(() => NoopPublisherVerification().Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements(),<br><span style="color:blue;">@@ -158,12 +165,11 @@ public void Required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates_shou</span><br>         public void Optional_spec105_emptyStreamMustTerminateBySignallingOnComplete_shouldNotAllowEagerOnComplete()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber => subscriber.OnComplete());<br><span style="color:orangered;">-            var verification = new Spec105Verification(new TestEnvironment(), publisher);</span><br><span style="color:green;">+            var verification = new Spec105Verification(new TestEnvironment(_output), publisher);</span><br>             RequireTestFailure(() => verification.Optional_spec105_emptyStreamMustTerminateBySignallingOnComplete(),<br>                 "Subscriber.OnComplete() called before Subscriber.OnSubscribe");<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper for single test")]</span><br>         private sealed class Spec105Verification : PublisherVerification<int><br>         {<br>             private readonly IPublisher<int> _publisher;<br><span style="color:blue;">@@ -525,7 +531,7 @@ private PublisherVerification<int> NoopPublisherVerification()</span><br>                 subscriber.OnSubscribe(new LamdaSubscription());<br>             });<br> <br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -541,21 +547,21 @@ private PublisherVerification<int> OnErroringPublisherVerification()</span><br>                 }));<br>             });<br> <br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br>         }<br> <br>         /// <summary><br>         /// Custom Verification using given Publishers<br>         /// </summary><br>         private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher)<br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(), publisher);</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(_output), publisher);</span><br> <br>         /// <summary><br>         /// Custom Verification using given Publishers<br>         /// </summary><br>         private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher,<br>             IPublisher<int> errorPublisher)<br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(), publisher, errorPublisher);</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(_output), publisher, errorPublisher);</span><br> <br>         /// <summary><br>         /// Verification using a Publisher that publishes elements even with no demand available<br><span style="color:blue;">@@ -571,13 +577,13 @@ private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerificatio</span><br>                         subscriber.OnNext((int)i);<br>                 }));<br>             });<br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br>         }<br> <br>         /// <summary><br>         /// Verification using a Publisher that publishes elements even with no demand available, from multiple threads (!).<br>         /// <br><span style="color:orangered;">-        /// Please note that exceptions thrown from onNext *will be swallowed* â€“ reason being this verification is used to check</span><br><span style="color:green;">+        /// Please note that exceptions thrown from onNext *will be swallowed* – reason being this verification is used to check</span><br>         /// very specific things about error reporting - from the "TCK Tests", we do not have any assertions on thrown exceptions.<br>         /// </summary><br>         private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(CancellationToken token)<br><span style="color:blue;">@@ -587,7 +593,7 @@ private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerificati</span><br>         /// Verification using a Publisher that publishes elements even with no demand available, from multiple threads (!).<br>         /// </summary><br>         private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(bool swallowOnNextExceptions, CancellationToken token)<br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(), new DemandIgnoringAsyncPublisher(swallowOnNextExceptions, token));</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(_output), new DemandIgnoringAsyncPublisher(swallowOnNextExceptions, token));</span><br> <br>         private sealed class DemandIgnoringAsyncPublisher : IPublisher<int><br>         {<br><span style="color:blue;">@@ -658,7 +664,6 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>                 }));<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper for single test")]</span><br>         private sealed class SimpleVerification : PublisherVerification<int><br>         {<br>             private readonly IPublisher<int> _publisher;<br><span style="color:blue;">@@ -680,6 +685,5 @@ public SimpleVerification(TestEnvironment environment, IPublisher<int> publisher</span><br>             public override IPublisher<int> CreateFailedPublisher() => _failedPublisher;<br>         }<br> <br><span style="color:orangered;">-        </span><br>     }<br> }<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index b0c6908..127ac85 100644<br><span style="color:blue;">@@ -10,14 +10,21 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    /// <summary></span><br><span style="color:orangered;">-    /// Validates that the TCK's <see cref="PublisherVerification{T}"/> fails with nice human readable errors.</span><br><span style="color:orangered;">-    /// >Important: Please note that all Publishers implemented in this file are *wrong*!</span><br><span style="color:orangered;">-    /// </summary></span><br><span style="color:green;">+{/// <summary></span><br><span style="color:green;">+{////// Validates that the TCK's <see cref="PublisherVerification{T}"/> fails with nice human readable errors.</span><br><span style="color:green;">+{////// >Important: Please note that all Publishers implemented in this file are *wrong*!</span><br><span style="color:green;">+{////// </summary></span><br>     public class PublisherVerificationTest : TCKVerificationSupport<br>     {<br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+        private readonly ITestOutputHelper _output;</span><br><span style="color:green;">+</span><br><span style="color:green;">+        public PublisherVerificationTest(ITestOutputHelper output)</span><br><span style="color:green;">+        {</span><br><span style="color:green;">+            _output = output;</span><br><span style="color:green;">+        }</span><br><span style="color:green;">+    {[SkippableFact]</span><br>         public void Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements_shouldFailBy_ExpectingOnError()<br>             => RequireTestFailure(() => NoopPublisherVerification().Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements(),<br>                     "produced no element after first");<br><span style="color:blue;">@@ -98,7 +105,7 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>                 }));<br>         }<br> <br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+[SkippableFact]</span><br>         public void Stochastic_spec103_mustSignalOnMethodsSequentially_shouldPass_forSynchronousPublisher()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br><span style="color:blue;">@@ -116,7 +123,7 @@ public void Stochastic_spec103_mustSignalOnMethodsSequentially_shouldPass_forSyn</span><br>             CustomPublisherVerification(publisher).Stochastic_spec103_mustSignalOnMethodsSequentially();<br>         }<br> <br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+[SkippableFact]</span><br>         public void Optional_spec104_mustSignalOnErrorWhenFails_shouldFail()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br><span style="color:blue;">@@ -514,11 +521,11 @@ public void Required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue_fo</span><br> <br>         // FAILING IMPLEMENTATIONS //<br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <summary></span><br>         /// Verification using a Publisher that never publishes any element.<br>         /// Skips the error state publisher tests.<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> NoopPublisherVerification()</span><br><span style="color:green;">+private PublisherVerification<int> NoopPublisherVerification()</span><br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br>             {<br><span style="color:blue;">@@ -531,7 +538,7 @@ private PublisherVerification<int> NoopPublisherVerification()</span><br>         /// <summary><br>         /// Verification using a Publisher that never publishes any element<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> OnErroringPublisherVerification()</span><br><span style="color:green;">+private PublisherVerification<int> OnErroringPublisherVerification()</span><br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br>             {<br><span style="color:blue;">@@ -547,17 +554,17 @@ private PublisherVerification<int> OnErroringPublisherVerification()</span><br>         /// <summary><br>         /// Custom Verification using given Publishers<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher)</span><br><span style="color:green;">+private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher)</span><br>             => new SimpleVerification(new TestEnvironment(), publisher);<br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <summary></span><br>         /// Custom Verification using given Publishers<br>         /// </summary><br>         private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher,<br>             IPublisher<int> errorPublisher)<br>             => new SimpleVerification(new TestEnvironment(), publisher, errorPublisher);<br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <sum/// <summary></span><br>         /// Verification using a Publisher that publishes elements even with no demand available<br>         /// </summary><br>         private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerification()<br><span style="color:blue;">@@ -577,10 +584,10 @@ private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerificatio</span><br>         /// <summary><br>         /// Verification using a Publisher that publishes elements even with no demand available, from multiple threads (!).<br>         /// <br><span style="color:orangered;">-        /// Please note that exceptions thrown from onNext *will be swallowed* â€“ reason being this verification is used to check</span><br><span style="color:green;">+        /// Please note that exceptions thrown from onNext *will be swallowed* – reason being this verification is used to check</span><br>         /// very specific things about error reporting - from the "TCK Tests", we do not have any assertions on thrown exceptions.<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(CancellationToken token)</span><br><span style="color:green;">+private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(CancellationToken token)</span><br>             => DemandIgnoringAsynchronousPublisherVerification(true, token);<br> <br>         /// <summary><br><span style="color:blue;">@@ -589,7 +596,7 @@ private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerificati</span><br>         private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(bool swallowOnNextExceptions, CancellationToken token)<br>             => new SimpleVerification(new TestEnvironment(), new DemandIgnoringAsyncPublisher(swallowOnNextExceptions, token));<br> <br><span style="color:orangered;">-        private sealed class DemandIgnoringAsyncPublisher : IPublisher<int></span><br><span style="color:green;">+private sealed class DemandIgnoringAsyncPublisher : IPublisher<int></span><br>         {<br>             private readonly bool _swallowOnNextExceptions;<br>             private readonly CancellationToken _token;<br><span style="color:blue;">@@ -658,7 +665,7 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>                 }));<br>         }<br> <br><span style="color:orangered;">-        [TestFixture(Ignore = "Helper for single test")]</span><br><span style="color:green;">+[TestFixture(Ignore = "Helper for single test")]</span><br>         private sealed class SimpleVerification : PublisherVerification<int><br>         {<br>             private readonly IPublisher<int> _publisher;<br><span style="color:blue;">@@ -679,7 +686,6 @@ public SimpleVerification(TestEnvironment environment, IPublisher<int> publisher</span><br> <br>             public override IPublisher<int> CreateFailedPublisher() => _failedPublisher;<br>         }<br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        </span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 3f39d56..127ac85 100644<br><span style="color:blue;">@@ -10,11 +10,12 @@</span><br> using Reactive.Streams.TCK.Tests.Support;<br> <br> namespace Reactive.Streams.TCK.Tests<br><span style="color:green;">+</span><br> {<br><span style="color:orangered;">-    /// <summary></span><br><span style="color:orangered;">-    /// Validates that the TCK's <see cref="PublisherVerification{T}"/> fails with nice human readable errors.</span><br><span style="color:orangered;">-    /// >Important: Please note that all Publishers implemented in this file are *wrong*!</span><br><span style="color:orangered;">-    /// </summary></span><br><span style="color:green;">+{/// <summary></span><br><span style="color:green;">+{////// Validates that the TCK's <see cref="PublisherVerification{T}"/> fails with nice human readable errors.</span><br><span style="color:green;">+{////// >Important: Please note that all Publishers implemented in this file are *wrong*!</span><br><span style="color:green;">+{////// </summary></span><br>     public class PublisherVerificationTest : TCKVerificationSupport<br>     {<br>         private readonly ITestOutputHelper _output;<br><span style="color:blue;">@@ -23,8 +24,7 @@ public PublisherVerificationTest(ITestOutputHelper output)</span><br>         {<br>             _output = output;<br>         }<br><span style="color:orangered;">-</span><br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+    {[SkippableFact]</span><br>         public void Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements_shouldFailBy_ExpectingOnError()<br>             => RequireTestFailure(() => NoopPublisherVerification().Required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements(),<br>                     "produced no element after first");<br><span style="color:blue;">@@ -105,7 +105,7 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>                 }));<br>         }<br> <br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+[SkippableFact]</span><br>         public void Stochastic_spec103_mustSignalOnMethodsSequentially_shouldPass_forSynchronousPublisher()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br><span style="color:blue;">@@ -123,7 +123,7 @@ public void Stochastic_spec103_mustSignalOnMethodsSequentially_shouldPass_forSyn</span><br>             CustomPublisherVerification(publisher).Stochastic_spec103_mustSignalOnMethodsSequentially();<br>         }<br> <br><span style="color:orangered;">-        [SkippableFact]</span><br><span style="color:green;">+[SkippableFact]</span><br>         public void Optional_spec104_mustSignalOnErrorWhenFails_shouldFail()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br><span style="color:blue;">@@ -165,11 +165,12 @@ public void Required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates_shou</span><br>         public void Optional_spec105_emptyStreamMustTerminateBySignallingOnComplete_shouldNotAllowEagerOnComplete()<br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber => subscriber.OnComplete());<br><span style="color:orangered;">-            var verification = new Spec105Verification(new TestEnvironment(_output), publisher);</span><br><span style="color:green;">+            var verification = new Spec105Verification(new TestEnvironment(), publisher);</span><br>             RequireTestFailure(() => verification.Optional_spec105_emptyStreamMustTerminateBySignallingOnComplete(),<br>                 "Subscriber.OnComplete() called before Subscriber.OnSubscribe");<br>         }<br> <br><span style="color:green;">+        [TestFixture(Ignore = "Helper for single test")]</span><br>         private sealed class Spec105Verification : PublisherVerification<int><br>         {<br>             private readonly IPublisher<int> _publisher;<br><span style="color:blue;">@@ -520,24 +521,24 @@ public void Required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue_fo</span><br> <br>         // FAILING IMPLEMENTATIONS //<br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <summary></span><br>         /// Verification using a Publisher that never publishes any element.<br>         /// Skips the error state publisher tests.<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> NoopPublisherVerification()</span><br><span style="color:green;">+private PublisherVerification<int> NoopPublisherVerification()</span><br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br>             {<br>                 subscriber.OnSubscribe(new LamdaSubscription());<br>             });<br> <br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(), publisher);</span><br>         }<br> <br>         /// <summary><br>         /// Verification using a Publisher that never publishes any element<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> OnErroringPublisherVerification()</span><br><span style="color:green;">+private PublisherVerification<int> OnErroringPublisherVerification()</span><br>         {<br>             var publisher = new LamdaPublisher<int>(onSubscribe: subscriber =><br>             {<br><span style="color:blue;">@@ -547,23 +548,23 @@ private PublisherVerification<int> OnErroringPublisherVerification()</span><br>                 }));<br>             });<br> <br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(), publisher);</span><br>         }<br> <br>         /// <summary><br>         /// Custom Verification using given Publishers<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher)</span><br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(_output), publisher);</span><br><span style="color:green;">+private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher)</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(), publisher);</span><br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <summary></span><br>         /// Custom Verification using given Publishers<br>         /// </summary><br>         private PublisherVerification<int> CustomPublisherVerification(IPublisher<int> publisher,<br>             IPublisher<int> errorPublisher)<br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(_output), publisher, errorPublisher);</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(), publisher, errorPublisher);</span><br> <br><span style="color:orangered;">-        /// <summary></span><br><span style="color:green;">+/// <sum/// <summary></span><br>         /// Verification using a Publisher that publishes elements even with no demand available<br>         /// </summary><br>         private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerification()<br><span style="color:blue;">@@ -577,7 +578,7 @@ private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerificatio</span><br>                         subscriber.OnNext((int)i);<br>                 }));<br>             });<br><span style="color:orangered;">-            return new SimpleVerification(new TestEnvironment(_output), publisher);</span><br><span style="color:green;">+            return new SimpleVerification(new TestEnvironment(), publisher);</span><br>         }<br> <br>         /// <summary><br><span style="color:blue;">@@ -586,16 +587,16 @@ private PublisherVerification<int> DemandIgnoringSynchronousPublisherVerificatio</span><br>         /// Please note that exceptions thrown from onNext *will be swallowed* – reason being this verification is used to check<br>         /// very specific things about error reporting - from the "TCK Tests", we do not have any assertions on thrown exceptions.<br>         /// </summary><br><span style="color:orangered;">-        private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(CancellationToken token)</span><br><span style="color:green;">+private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(CancellationToken token)</span><br>             => DemandIgnoringAsynchronousPublisherVerification(true, token);<br> <br>         /// <summary><br>         /// Verification using a Publisher that publishes elements even with no demand available, from multiple threads (!).<br>         /// </summary><br>         private PublisherVerification<int> DemandIgnoringAsynchronousPublisherVerification(bool swallowOnNextExceptions, CancellationToken token)<br><span style="color:orangered;">-            => new SimpleVerification(new TestEnvironment(_output), new DemandIgnoringAsyncPublisher(swallowOnNextExceptions, token));</span><br><span style="color:green;">+            => new SimpleVerification(new TestEnvironment(), new DemandIgnoringAsyncPublisher(swallowOnNextExceptions, token));</span><br> <br><span style="color:orangered;">-        private sealed class DemandIgnoringAsyncPublisher : IPublisher<int></span><br><span style="color:green;">+private sealed class DemandIgnoringAsyncPublisher : IPublisher<int></span><br>         {<br>             private readonly bool _swallowOnNextExceptions;<br>             private readonly CancellationToken _token;<br><span style="color:blue;">@@ -664,6 +665,7 @@ public void Subscribe(ISubscriber<int> subscriber)</span><br>                 }));<br>         }<br> <br><span style="color:green;">+[TestFixture(Ignore = "Helper for single test")]</span><br>         private sealed class SimpleVerification : PublisherVerification<int><br>         {<br>             private readonly IPublisher<int> _publisher;<br><span style="color:blue;">@@ -684,6 +686,6 @@ public SimpleVerification(TestEnvironment environment, IPublisher<int> publisher</span><br> <br>             public override IPublisher<int> CreateFailedPublisher() => _failedPublisher;<br>         }<br><span style="color:orangered;">-</span><br>     }<br><span style="color:orangered;">-}</span><br><span style="color:green;">+</span><br><span style="color:green;">+}</span><br>\ No newline at end of file<br></pre></body></html>