<html><body><pre><hr><h1>whisper\tokenizer.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\test_tokenizer.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\audio.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\version.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\__init__.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\test_audio.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\model.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\test_transcribe.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\decoding.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\normalizers\english.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\normalizers\basic.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>setup.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\__main__.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\triton_ops.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\conftest.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\timing.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\test_normalizer.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>tests\test_timing.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\normalizers\__init__.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2><br>No diff<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><hr><h1>whisper\transcribe.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index ed6d820..84feb12 100644<br><span style="color:blue;">@@ -401,6 +401,9 @@ def cli():</span><br>     parser.add_argument("--word_timestamps", type=str2bool, default=False, help="(experimental) extract word-level timestamps and refine the results based on them")<br>     parser.add_argument("--prepend_punctuations", type=str, default="\"\'“¿([{-", help="if word_timestamps is True, merge these punctuation symbols with the next word")<br>     parser.add_argument("--append_punctuations", type=str, default="\"\'.。,，!！?？:：”)]}、", help="if word_timestamps is True, merge these punctuation symbols with the previous word")<br><span style="color:green;">+    parser.add_argument("--highlight_words", type=str2bool, default=False, help="(requires --word_timestamps True) underline each word as it is spoken in srt and vtt")</span><br><span style="color:green;">+    parser.add_argument("--max_line_width", type=optional_int, default=None, help="(requires --word_timestamps True) the maximum number of characters in a line before breaking the line")</span><br><span style="color:green;">+    parser.add_argument("--max_line_count", type=optional_int, default=None, help="(requires --word_timestamps True) the maximum number of lines in a segment")</span><br>     parser.add_argument("--threads", type=optional_int, default=0, help="number of threads used by torch for CPU inference; supercedes MKL_NUM_THREADS/OMP_NUM_THREADS")<br>     # fmt: on<br> <br><span style="color:blue;">@@ -433,9 +436,17 @@ def cli():</span><br>     model = load_model(model_name, device=device, download_root=model_dir)<br> <br>     writer = get_writer(output_format, output_dir)<br><span style="color:green;">+    word_options = ["highlight_words", "max_line_count", "max_line_width"]</span><br><span style="color:green;">+    if not args["word_timestamps"]:</span><br><span style="color:green;">+        for option in word_options:</span><br><span style="color:green;">+            if args[option]:</span><br><span style="color:green;">+                parser.error(f"--{option} requires --word_timestamps True")</span><br><span style="color:green;">+    if args["max_line_count"] and not args["max_line_width"]:</span><br><span style="color:green;">+        warnings.warn("--max_line_count has no effect without --max_line_width")</span><br><span style="color:green;">+    writer_args = {arg: args.pop(arg) for arg in word_options}</span><br>     for audio_path in args.pop("audio"):<br>         result = transcribe(model, audio_path, temperature=temperature, **args)<br><span style="color:orangered;">-        writer(result, audio_path)</span><br><span style="color:green;">+        writer(result, audio_path, writer_args)</span><br> <br> <br> if __name__ == "__main__":<br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2><br>No diff<br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index 84feb12..ed6d820 100644<br><span style="color:blue;">@@ -401,9 +401,6 @@ def cli():</span><br>     parser.add_argument("--word_timestamps", type=str2bool, default=False, help="(experimental) extract word-level timestamps and refine the results based on them")<br>     parser.add_argument("--prepend_punctuations", type=str, default="\"\'“¿([{-", help="if word_timestamps is True, merge these punctuation symbols with the next word")<br>     parser.add_argument("--append_punctuations", type=str, default="\"\'.。,，!！?？:：”)]}、", help="if word_timestamps is True, merge these punctuation symbols with the previous word")<br><span style="color:orangered;">-    parser.add_argument("--highlight_words", type=str2bool, default=False, help="(requires --word_timestamps True) underline each word as it is spoken in srt and vtt")</span><br><span style="color:orangered;">-    parser.add_argument("--max_line_width", type=optional_int, default=None, help="(requires --word_timestamps True) the maximum number of characters in a line before breaking the line")</span><br><span style="color:orangered;">-    parser.add_argument("--max_line_count", type=optional_int, default=None, help="(requires --word_timestamps True) the maximum number of lines in a segment")</span><br>     parser.add_argument("--threads", type=optional_int, default=0, help="number of threads used by torch for CPU inference; supercedes MKL_NUM_THREADS/OMP_NUM_THREADS")<br>     # fmt: on<br> <br><span style="color:blue;">@@ -436,17 +433,9 @@ def cli():</span><br>     model = load_model(model_name, device=device, download_root=model_dir)<br> <br>     writer = get_writer(output_format, output_dir)<br><span style="color:orangered;">-    word_options = ["highlight_words", "max_line_count", "max_line_width"]</span><br><span style="color:orangered;">-    if not args["word_timestamps"]:</span><br><span style="color:orangered;">-        for option in word_options:</span><br><span style="color:orangered;">-            if args[option]:</span><br><span style="color:orangered;">-                parser.error(f"--{option} requires --word_timestamps True")</span><br><span style="color:orangered;">-    if args["max_line_count"] and not args["max_line_width"]:</span><br><span style="color:orangered;">-        warnings.warn("--max_line_count has no effect without --max_line_width")</span><br><span style="color:orangered;">-    writer_args = {arg: args.pop(arg) for arg in word_options}</span><br>     for audio_path in args.pop("audio"):<br>         result = transcribe(model, audio_path, temperature=temperature, **args)<br><span style="color:orangered;">-        writer(result, audio_path, writer_args)</span><br><span style="color:green;">+        writer(result, audio_path)</span><br> <br> <br> if __name__ == "__main__":<br><hr><h1>whisper\utils.py</h1><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Target</span></h2>index 490bdd1..ba5a10c 100644<br><span style="color:blue;">@@ -1,8 +1,9 @@</span><br> import json<br> import os<br><span style="color:green;">+import re</span><br> import sys<br> import zlib<br><span style="color:orangered;">-from typing import Callable, TextIO</span><br><span style="color:green;">+from typing import Callable, Optional, TextIO</span><br> <br> system_encoding = sys.getdefaultencoding()<br> <br><span style="color:blue;">@@ -73,7 +74,7 @@ class ResultWriter:</span><br>     def __init__(self, output_dir: str):<br>         self.output_dir = output_dir<br> <br><span style="color:orangered;">-    def __call__(self, result: dict, audio_path: str):</span><br><span style="color:green;">+    def __call__(self, result: dict, audio_path: str, options: dict):</span><br>         audio_basename = os.path.basename(audio_path)<br>         audio_basename = os.path.splitext(audio_basename)[0]<br>         output_path = os.path.join(<br><span style="color:blue;">@@ -81,16 +82,16 @@ def __call__(self, result: dict, audio_path: str):</span><br>         )<br> <br>         with open(output_path, "w", encoding="utf-8") as f:<br><span style="color:orangered;">-            self.write_result(result, file=f)</span><br><span style="color:green;">+            self.write_result(result, file=f, options=options)</span><br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         raise NotImplementedError<br> <br> <br> class WriteTXT(ResultWriter):<br>     extension: str = "txt"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         for segment in result["segments"]:<br>             print(segment["text"].strip(), file=file, flush=True)<br> <br><span style="color:blue;">@@ -99,33 +100,81 @@ class SubtitlesWriter(ResultWriter):</span><br>     always_include_hours: bool<br>     decimal_marker: str<br> <br><span style="color:orangered;">-    def iterate_result(self, result: dict):</span><br><span style="color:orangered;">-        for segment in result["segments"]:</span><br><span style="color:orangered;">-            segment_start = self.format_timestamp(segment["start"])</span><br><span style="color:orangered;">-            segment_end = self.format_timestamp(segment["end"])</span><br><span style="color:orangered;">-            segment_text = segment["text"].strip().replace("-->", "->")</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            if word_timings := segment.get("words", None):</span><br><span style="color:orangered;">-                all_words = [timing["word"] for timing in word_timings]</span><br><span style="color:orangered;">-                all_words[0] = all_words[0].strip()  # remove the leading space, if any</span><br><span style="color:orangered;">-                last = segment_start</span><br><span style="color:orangered;">-                for i, this_word in enumerate(word_timings):</span><br><span style="color:orangered;">-                    start = self.format_timestamp(this_word["start"])</span><br><span style="color:orangered;">-                    end = self.format_timestamp(this_word["end"])</span><br><span style="color:orangered;">-                    if last != start:</span><br><span style="color:orangered;">-                        yield last, start, segment_text</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    yield start, end, "".join(</span><br><span style="color:orangered;">-                        [</span><br><span style="color:orangered;">-                            f"<u>{word}</u>" if j == i else word</span><br><span style="color:orangered;">-                            for j, word in enumerate(all_words)</span><br><span style="color:orangered;">-                        ]</span><br><span style="color:orangered;">-                    )</span><br><span style="color:orangered;">-                    last = end</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                if last != segment_end:</span><br><span style="color:orangered;">-                    yield last, segment_end, segment_text</span><br><span style="color:orangered;">-            else:</span><br><span style="color:green;">+    def iterate_result(self, result: dict, options: dict):</span><br><span style="color:green;">+        raw_max_line_width: Optional[int] = options["max_line_width"]</span><br><span style="color:green;">+        max_line_count: Optional[int] = options["max_line_count"]</span><br><span style="color:green;">+        highlight_words: bool = options["highlight_words"]</span><br><span style="color:green;">+        max_line_width = 1000 if raw_max_line_width is None else raw_max_line_width</span><br><span style="color:green;">+        preserve_segments = max_line_count is None or raw_max_line_width is None</span><br><span style="color:green;">+</span><br><span style="color:green;">+        def iterate_subtitles():</span><br><span style="color:green;">+            line_len = 0</span><br><span style="color:green;">+            line_count = 1</span><br><span style="color:green;">+            # the next subtitle to yield (a list of word timings with whitespace)</span><br><span style="color:green;">+            subtitle: list[dict] = []</span><br><span style="color:green;">+            last = result["segments"][0]["words"][0]["start"]</span><br><span style="color:green;">+            for segment in result["segments"]:</span><br><span style="color:green;">+                for i, original_timing in enumerate(segment["words"]):</span><br><span style="color:green;">+                    timing = original_timing.copy()</span><br><span style="color:green;">+                    long_pause = not preserve_segments and timing["start"] - last > 3.0</span><br><span style="color:green;">+                    has_room = line_len + len(timing["word"]) <= max_line_width</span><br><span style="color:green;">+                    seg_break = i == 0 and len(subtitle) > 0 and preserve_segments</span><br><span style="color:green;">+                    if line_len > 0 and has_room and not long_pause and not seg_break:</span><br><span style="color:green;">+                        # line continuation</span><br><span style="color:green;">+                        line_len += len(timing["word"])</span><br><span style="color:green;">+                    else:</span><br><span style="color:green;">+                        # new line</span><br><span style="color:green;">+                        timing["word"] = timing["word"].strip()</span><br><span style="color:green;">+                        if (</span><br><span style="color:green;">+                            len(subtitle) > 0</span><br><span style="color:green;">+                            and max_line_count is not None</span><br><span style="color:green;">+                            and (long_pause or line_count >= max_line_count)</span><br><span style="color:green;">+                            or seg_break</span><br><span style="color:green;">+                        ):</span><br><span style="color:green;">+                            # subtitle break</span><br><span style="color:green;">+                            yield subtitle</span><br><span style="color:green;">+                            subtitle = []</span><br><span style="color:green;">+                            line_count = 1</span><br><span style="color:green;">+                        elif line_len > 0:</span><br><span style="color:green;">+                            # line break</span><br><span style="color:green;">+                            line_count += 1</span><br><span style="color:green;">+                            timing["word"] = "\n" + timing["word"]</span><br><span style="color:green;">+                        line_len = len(timing["word"].strip())</span><br><span style="color:green;">+                    subtitle.append(timing)</span><br><span style="color:green;">+                    last = timing["start"]</span><br><span style="color:green;">+            if len(subtitle) > 0:</span><br><span style="color:green;">+                yield subtitle</span><br><span style="color:green;">+</span><br><span style="color:green;">+        if "words" in result["segments"][0]:</span><br><span style="color:green;">+            for subtitle in iterate_subtitles():</span><br><span style="color:green;">+                subtitle_start = self.format_timestamp(subtitle[0]["start"])</span><br><span style="color:green;">+                subtitle_end = self.format_timestamp(subtitle[-1]["end"])</span><br><span style="color:green;">+                subtitle_text = "".join([word["word"] for word in subtitle])</span><br><span style="color:green;">+                if highlight_words:</span><br><span style="color:green;">+                    last = subtitle_start</span><br><span style="color:green;">+                    all_words = [timing["word"] for timing in subtitle]</span><br><span style="color:green;">+                    for i, this_word in enumerate(subtitle):</span><br><span style="color:green;">+                        start = self.format_timestamp(this_word["start"])</span><br><span style="color:green;">+                        end = self.format_timestamp(this_word["end"])</span><br><span style="color:green;">+                        if last != start:</span><br><span style="color:green;">+                            yield last, start, subtitle_text</span><br><span style="color:green;">+</span><br><span style="color:green;">+                        yield start, end, "".join(</span><br><span style="color:green;">+                            [</span><br><span style="color:green;">+                                re.sub(r"^(\s*)(.*)$", r"\1<u>\2</u>", word)</span><br><span style="color:green;">+                                if j == i</span><br><span style="color:green;">+                                else word</span><br><span style="color:green;">+                                for j, word in enumerate(all_words)</span><br><span style="color:green;">+                            ]</span><br><span style="color:green;">+                        )</span><br><span style="color:green;">+                        last = end</span><br><span style="color:green;">+                else:</span><br><span style="color:green;">+                    yield subtitle_start, subtitle_end, subtitle_text</span><br><span style="color:green;">+        else:</span><br><span style="color:green;">+            for segment in result["segments"]:</span><br><span style="color:green;">+                segment_start = self.format_timestamp(segment["start"])</span><br><span style="color:green;">+                segment_end = self.format_timestamp(segment["end"])</span><br><span style="color:green;">+                segment_text = segment["text"].strip().replace("-->", "->")</span><br>                 yield segment_start, segment_end, segment_text<br> <br>     def format_timestamp(self, seconds: float):<br><span style="color:blue;">@@ -141,9 +190,9 @@ class WriteVTT(SubtitlesWriter):</span><br>     always_include_hours: bool = False<br>     decimal_marker: str = "."<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         print("WEBVTT\n", file=file)<br><span style="color:orangered;">-        for start, end, text in self.iterate_result(result):</span><br><span style="color:green;">+        for start, end, text in self.iterate_result(result, options):</span><br>             print(f"{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -152,8 +201,10 @@ class WriteSRT(SubtitlesWriter):</span><br>     always_include_hours: bool = True<br>     decimal_marker: str = ","<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:orangered;">-        for i, (start, end, text) in enumerate(self.iterate_result(result), start=1):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+        for i, (start, end, text) in enumerate(</span><br><span style="color:green;">+            self.iterate_result(result, options), start=1</span><br><span style="color:green;">+        ):</span><br>             print(f"{i}\n{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -169,7 +220,7 @@ class WriteTSV(ResultWriter):</span><br> <br>     extension: str = "tsv"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         print("start", "end", "text", sep="\t", file=file)<br>         for segment in result["segments"]:<br>             print(round(1000 * segment["start"]), file=file, end="\t")<br><span style="color:blue;">@@ -180,11 +231,13 @@ def write_result(self, result: dict, file: TextIO):</span><br> class WriteJSON(ResultWriter):<br>     extension: str = "json"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         json.dump(result, file)<br> <br> <br><span style="color:orangered;">-def get_writer(output_format: str, output_dir: str) -> Callable[[dict, TextIO], None]:</span><br><span style="color:green;">+def get_writer(</span><br><span style="color:green;">+    output_format: str, output_dir: str</span><br><span style="color:green;">+) -> Callable[[dict, TextIO, dict], None]:</span><br>     writers = {<br>         "txt": WriteTXT,<br>         "vtt": WriteVTT,<br><span style="color:blue;">@@ -196,9 +249,9 @@ def get_writer(output_format: str, output_dir: str) -> Callable[[dict, TextIO],</span><br>     if output_format == "all":<br>         all_writers = [writer(output_dir) for writer in writers.values()]<br> <br><span style="color:orangered;">-        def write_all(result: dict, file: TextIO):</span><br><span style="color:green;">+        def write_all(result: dict, file: TextIO, options: dict):</span><br>             for writer in all_writers:<br><span style="color:orangered;">-                writer(result, file)</span><br><span style="color:green;">+                writer(result, file, options)</span><br> <br>         return write_all<br> <br><h2><span style="color:orangered;">Source</span> vs <span style="color:green;">Predicted</span></h2>index 490bdd1..18ee999 100644<br><span style="color:blue;">@@ -1,8 +1,9 @@</span><br> import json<br> import os<br><span style="color:green;">+import re</span><br> import sys<br> import zlib<br><span style="color:orangered;">-from typing import Callable, TextIO</span><br><span style="color:green;">+from typing import Callable, Optional, TextIO</span><br> <br> system_encoding = sys.getdefaultencoding()<br> <br><span style="color:blue;">@@ -81,16 +82,16 @@ def __call__(self, result: dict, audio_path: str):</span><br>         )<br> <br>         with open(output_path, "w", encoding="utf-8") as f:<br><span style="color:orangered;">-            self.write_result(result, file=f)</span><br><span style="color:green;">+            self.write_result(result, file=f, options=result)</span><br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         raise NotImplementedError<br> <br> <br> class WriteTXT(ResultWriter):<br>     extension: str = "txt"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(self, result: dict, file: TextIO, options: dict):</span><br>         for segment in result["segments"]:<br>             print(segment["text"].strip(), file=file, flush=True)<br> <br><span style="color:blue;">@@ -99,33 +100,81 @@ class SubtitlesWriter(ResultWriter):</span><br>     always_include_hours: bool<br>     decimal_marker: str<br> <br><span style="color:orangered;">-    def iterate_result(self, result: dict):</span><br><span style="color:orangered;">-        for segment in result["segments"]:</span><br><span style="color:orangered;">-            segment_start = self.format_timestamp(segment["start"])</span><br><span style="color:orangered;">-            segment_end = self.format_timestamp(segment["end"])</span><br><span style="color:orangered;">-            segment_text = segment["text"].strip().replace("-->", "->")</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-            if word_timings := segment.get("words", None):</span><br><span style="color:orangered;">-                all_words = [timing["word"] for timing in word_timings]</span><br><span style="color:orangered;">-                all_words[0] = all_words[0].strip()  # remove the leading space, if any</span><br><span style="color:orangered;">-                last = segment_start</span><br><span style="color:orangered;">-                for i, this_word in enumerate(word_timings):</span><br><span style="color:orangered;">-                    start = self.format_timestamp(this_word["start"])</span><br><span style="color:orangered;">-                    end = self.format_timestamp(this_word["end"])</span><br><span style="color:orangered;">-                    if last != start:</span><br><span style="color:orangered;">-                        yield last, start, segment_text</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                    yield start, end, "".join(</span><br><span style="color:orangered;">-                        [</span><br><span style="color:orangered;">-                            f"<u>{word}</u>" if j == i else word</span><br><span style="color:orangered;">-                            for j, word in enumerate(all_words)</span><br><span style="color:orangered;">-                        ]</span><br><span style="color:orangered;">-                    )</span><br><span style="color:orangered;">-                    last = end</span><br><span style="color:orangered;">-</span><br><span style="color:orangered;">-                if last != segment_end:</span><br><span style="color:orangered;">-                    yield last, segment_end, segment_text</span><br><span style="color:orangered;">-            else:</span><br><span style="color:green;">+    def iterate_result(self, result: dict, options: dict):</span><br><span style="color:green;">+        raw_max_line_width: Optional[int] = options["max_line_width"]</span><br><span style="color:green;">+        max_line_count: Optional[int] = options["max_line_count"]</span><br><span style="color:green;">+        highlight_words: bool = options["highlight_words"]</span><br><span style="color:green;">+        max_line_width = 1000 if raw_max_line_width is None else raw_max_line_width</span><br><span style="color:green;">+        preserve_segments = max_line_count is None or raw_max_line_width is None</span><br><span style="color:green;">+</span><br><span style="color:green;">+        def iterate_subtitles():</span><br><span style="color:green;">+            line_len = 0</span><br><span style="color:green;">+            line_count = 1</span><br><span style="color:green;">+            # the next subtitle to yield (a list of word timings with whitespace)</span><br><span style="color:green;">+            subtitle: list[dict] = []</span><br><span style="color:green;">+            last = result["segments"][0]["words"][0]["start"]</span><br><span style="color:green;">+            for segment in result["segments"]:</span><br><span style="color:green;">+                for i, original_timing in enumerate(segment["words"]):</span><br><span style="color:green;">+                    timing = original_timing.copy()</span><br><span style="color:green;">+                    long_pause = not preserve_segments and timing["start"] - last > 3.0</span><br><span style="color:green;">+                    has_room = line_len + len(timing["word"]) <= max_line_width</span><br><span style="color:green;">+                    seg_break = i == 0 and len(subtitle) > 0 and preserve_segments</span><br><span style="color:green;">+                    if line_len > 0 and has_room and not long_pause and not seg_break:</span><br><span style="color:green;">+                        # line continuation</span><br><span style="color:green;">+                        line_len += len(timing["word"])</span><br><span style="color:green;">+                    else:</span><br><span style="color:green;">+                        # new line</span><br><span style="color:green;">+                        timing["word"] = timing["word"].strip()</span><br><span style="color:green;">+                        if (</span><br><span style="color:green;">+                            len(subtitle) > 0</span><br><span style="color:green;">+                            and max_line_count is not None</span><br><span style="color:green;">+                            and (long_pause or line_count >= max_line_count)</span><br><span style="color:green;">+                            or seg_break</span><br><span style="color:green;">+                        ):</span><br><span style="color:green;">+                            # subtitle break</span><br><span style="color:green;">+                            yield subtitle</span><br><span style="color:green;">+                            subtitle = []</span><br><span style="color:green;">+                            line_count = 1</span><br><span style="color:green;">+                        elif line_len > 0:</span><br><span style="color:green;">+                            # line break</span><br><span style="color:green;">+                            line_count += 1</span><br><span style="color:green;">+                            timing["word"] = "\n" + timing["word"]</span><br><span style="color:green;">+                        line_len = len(timing["word"].strip())</span><br><span style="color:green;">+                    subtitle.append(timing)</span><br><span style="color:green;">+                    last = timing["start"]</span><br><span style="color:green;">+            if len(subtitle) > 0:</span><br><span style="color:green;">+                yield subtitle</span><br><span style="color:green;">+</span><br><span style="color:green;">+        if "words" in result["segments"][0]:</span><br><span style="color:green;">+            for subtitle in iterate_subtitles():</span><br><span style="color:green;">+                subtitle_start = self.format_timestamp(subtitle[0]["start"])</span><br><span style="color:green;">+                subtitle_end = self.format_timestamp(subtitle[-1]["end"])</span><br><span style="color:green;">+                subtitle_text = "".join([word["word"] for word in subtitle])</span><br><span style="color:green;">+                if highlight_words:</span><br><span style="color:green;">+                    last = subtitle_start</span><br><span style="color:green;">+                    all_words = [timing["word"] for timing in subtitle]</span><br><span style="color:green;">+                    for i, this_word in enumerate(subtitle):</span><br><span style="color:green;">+                        start = self.format_timestamp(this_word["start"])</span><br><span style="color:green;">+                        end = self.format_timestamp(this_word["end"])</span><br><span style="color:green;">+                        if last != start:</span><br><span style="color:green;">+                            yield last, start, subtitle_text</span><br><span style="color:green;">+</span><br><span style="color:green;">+                        yield start, end, "".join(</span><br><span style="color:green;">+                            [</span><br><span style="color:green;">+                                re.sub(r"^(\s*)(.*)$", r"\1<u>\2</u>", word)</span><br><span style="color:green;">+                                if j == i</span><br><span style="color:green;">+                                else word</span><br><span style="color:green;">+                                for j, word in enumerate(all_words)</span><br><span style="color:green;">+                            ]</span><br><span style="color:green;">+                        )</span><br><span style="color:green;">+                        last = end</span><br><span style="color:green;">+                else:</span><br><span style="color:green;">+                    yield subtitle_start, subtitle_end, subtitle_text</span><br><span style="color:green;">+        else:</span><br><span style="color:green;">+            for segment in result["segments"]:</span><br><span style="color:green;">+                segment_start = self.format_timestamp(segment["start"])</span><br><span style="color:green;">+                segment_end = self.format_timestamp(segment["end"])</span><br><span style="color:green;">+                segment_text = segment["text"].strip().replace("-->", "->")</span><br>                 yield segment_start, segment_end, segment_text<br> <br>     def format_timestamp(self, seconds: float):<br><span style="color:blue;">@@ -141,9 +190,9 @@ class WriteVTT(SubtitlesWriter):</span><br>     always_include_hours: bool = False<br>     decimal_marker: str = "."<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         print("WEBVTT\n", file=file)<br><span style="color:orangered;">-        for start, end, text in self.iterate_result(result):</span><br><span style="color:green;">+        for start, end, text in self.iterate_result(result, options=options):</span><br>             print(f"{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -152,8 +201,8 @@ class WriteSRT(SubtitlesWriter):</span><br>     always_include_hours: bool = True<br>     decimal_marker: str = ","<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:orangered;">-        for i, (start, end, text) in enumerate(self.iterate_result(result), start=1):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+        for i, (start, end, text) in enumerate(self.iterate_result(result, options=options), start=1):</span><br>             print(f"{i}\n{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -169,7 +218,7 @@ class WriteTSV(ResultWriter):</span><br> <br>     extension: str = "tsv"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         print("start", "end", "text", sep="\t", file=file)<br>         for segment in result["segments"]:<br>             print(round(1000 * segment["start"]), file=file, end="\t")<br><span style="color:blue;">@@ -180,7 +229,7 @@ def write_result(self, result: dict, file: TextIO):</span><br> class WriteJSON(ResultWriter):<br>     extension: str = "json"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         json.dump(result, file)<br> <br> <br><h2><span style="color:orangered;">Target</span> vs <span style="color:green;">Predicted</span></h2>index ba5a10c..18ee999 100644<br><span style="color:blue;">@@ -74,7 +74,7 @@ class ResultWriter:</span><br>     def __init__(self, output_dir: str):<br>         self.output_dir = output_dir<br> <br><span style="color:orangered;">-    def __call__(self, result: dict, audio_path: str, options: dict):</span><br><span style="color:green;">+    def __call__(self, result: dict, audio_path: str):</span><br>         audio_basename = os.path.basename(audio_path)<br>         audio_basename = os.path.splitext(audio_basename)[0]<br>         output_path = os.path.join(<br><span style="color:blue;">@@ -82,7 +82,7 @@ def __call__(self, result: dict, audio_path: str, options: dict):</span><br>         )<br> <br>         with open(output_path, "w", encoding="utf-8") as f:<br><span style="color:orangered;">-            self.write_result(result, file=f, options=options)</span><br><span style="color:green;">+            self.write_result(result, file=f, options=result)</span><br> <br>     def write_result(self, result: dict, file: TextIO, options: dict):<br>         raise NotImplementedError<br><span style="color:blue;">@@ -190,9 +190,9 @@ class WriteVTT(SubtitlesWriter):</span><br>     always_include_hours: bool = False<br>     decimal_marker: str = "."<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         print("WEBVTT\n", file=file)<br><span style="color:orangered;">-        for start, end, text in self.iterate_result(result, options):</span><br><span style="color:green;">+        for start, end, text in self.iterate_result(result, options=options):</span><br>             print(f"{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -201,10 +201,8 @@ class WriteSRT(SubtitlesWriter):</span><br>     always_include_hours: bool = True<br>     decimal_marker: str = ","<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO, options: dict):</span><br><span style="color:orangered;">-        for i, (start, end, text) in enumerate(</span><br><span style="color:orangered;">-            self.iterate_result(result, options), start=1</span><br><span style="color:orangered;">-        ):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+        for i, (start, end, text) in enumerate(self.iterate_result(result, options=options), start=1):</span><br>             print(f"{i}\n{start} --> {end}\n{text}\n", file=file, flush=True)<br> <br> <br><span style="color:blue;">@@ -220,7 +218,7 @@ class WriteTSV(ResultWriter):</span><br> <br>     extension: str = "tsv"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         print("start", "end", "text", sep="\t", file=file)<br>         for segment in result["segments"]:<br>             print(round(1000 * segment["start"]), file=file, end="\t")<br><span style="color:blue;">@@ -231,13 +229,11 @@ def write_result(self, result: dict, file: TextIO, options: dict):</span><br> class WriteJSON(ResultWriter):<br>     extension: str = "json"<br> <br><span style="color:orangered;">-    def write_result(self, result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+    def write_result(result: dict, file: TextIO, options: dict):</span><br>         json.dump(result, file)<br> <br> <br><span style="color:orangered;">-def get_writer(</span><br><span style="color:orangered;">-    output_format: str, output_dir: str</span><br><span style="color:orangered;">-) -> Callable[[dict, TextIO, dict], None]:</span><br><span style="color:green;">+def get_writer(output_format: str, output_dir: str) -> Callable[[dict, TextIO], None]:</span><br>     writers = {<br>         "txt": WriteTXT,<br>         "vtt": WriteVTT,<br><span style="color:blue;">@@ -249,9 +245,9 @@ def get_writer(</span><br>     if output_format == "all":<br>         all_writers = [writer(output_dir) for writer in writers.values()]<br> <br><span style="color:orangered;">-        def write_all(result: dict, file: TextIO, options: dict):</span><br><span style="color:green;">+        def write_all(result: dict, file: TextIO):</span><br>             for writer in all_writers:<br><span style="color:orangered;">-                writer(result, file, options)</span><br><span style="color:green;">+                writer(result, file)</span><br> <br>         return write_all<br> <br></pre></body></html>